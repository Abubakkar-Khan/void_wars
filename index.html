<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>VOID WARS ‚Äî Duel of Flagships</title>
<style>
  :root{
    --fg:#eaffff; --muted:#9bb0bd; --line:rgba(255,255,255,.08);
    --panel:rgba(10,12,20,.72); --panel-strong:rgba(10,12,20,.92);
    --accent:#00faff; --danger:#ff4d7a; --good:#50ffa8; --gold:#ffd36b;
    --enemy:#ff4d7a; --ally:#51d9ff;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:radial-gradient(1400px 900px at 50% 30%,#0a0f1c 0%,#05060b 45%,#030409 100%);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;overflow:hidden}
  canvas{display:block;width:100vw;height:100vh;image-rendering:pixelated}

  /* HUD (auto-fit) */
  .hud{position:fixed;inset:8px 8px auto 8px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;pointer-events:none}
  .chip{pointer-events:none;background:var(--panel);border:1px solid var(--line);padding:6px 10px;border-radius:10px;display:flex;align-items:center;gap:8px;font-size:12px}
  .chip .bar{position:relative; width:140px;height:8px;border-radius:8px;background:rgba(255,255,255,.06);border:1px solid var(--line);overflow:hidden}
  .chip .bar>i{position:absolute;inset:0;background:linear-gradient(90deg,var(--good),#9cffea,var(--accent))}
  .badge{background:rgba(255,255,255,.06);border:1px solid var(--line);padding:2px 6px;border-radius:8px;color:var(--muted);font-size:11px}
  .money{color:var(--gold)}
  .kbd{font-family:ui-monospace, Menlo, Consolas, monospace;background:rgba(255,255,255,.06);border:1px solid var(--line);padding:1px 4px;border-radius:6px}

  /* Bottom deploy bar */
  .deploy{position:fixed;left:8px;right:8px;bottom:8px;display:flex;gap:8px}
  .card{flex:1;min-width:0;background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:6px 8px;display:flex;align-items:center;gap:8px}
  .btn{appearance:none;border:1px solid var(--line);background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));color:var(--fg);padding:8px 10px;border-radius:10px;cursor:pointer;transition:.15s transform,.2s box-shadow,.2s border-color}
  .btn:hover{transform:translateY(-1px);box-shadow:0 10px 18px rgba(0,0,0,.25)}
  .btn.primary{border-color:rgba(0,250,255,.35)}
  .btn.danger{border-color:rgba(255,59,106,.35)}
  .row{display:flex;gap:8px;align-items:center}
  .grow{flex:1}
  .cooldown{height:6px;background:rgba(255,255,255,.06);border:1px solid var(--line);border-radius:8px;overflow:hidden}
  .cooldown>i{display:block;height:100%;background:linear-gradient(90deg,#79e5ff,#9a5cff);width:0%}

  /* Modals */
  .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center}
  .overlay.show{display:flex}
  .modal{pointer-events:auto;width:min(980px,96vw);max-height:86vh;overflow:auto;background:var(--panel-strong);border:1px solid var(--line);border-radius:16px;backdrop-filter:blur(12px);padding:14px;box-shadow:0 20px 60px rgba(0,0,0,.45)}
  .title{font-weight:800;letter-spacing:2px;text-transform:uppercase;color:var(--accent)}
  .list{display:flex;flex-direction:column;gap:8px}
  .shop-grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px;max-height:58vh;overflow:auto;padding-right:4px}
  .shop-item{display:flex;gap:10px;align-items:center;background:rgba(255,255,255,.04);border:1px solid var(--line);border-radius:12px;padding:8px}
  .shop-item .price{margin-left:auto}

  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:22px;background:var(--panel-strong);border:1px solid var(--line);padding:8px 12px;border-radius:10px;opacity:0;pointer-events:none}
  .toast.show{animation:toast 2.2s ease}@keyframes toast{0%{opacity:0;transform:translate(-50%,8px)}10%{opacity:1;transform:translate(-50%,0)}90%{opacity:1}100%{opacity:0}}

  /* Small helpers */
  .corner{position:fixed;bottom:8px;right:8px;display:flex;gap:8px}
</style>
</head>
<body>
<canvas id="cv"></canvas>

<!-- HUD -->
<div class="hud" id="hud">
  <div class="chip"><strong>VOID WARS</strong> <span id="speedChip" class="badge">1√ó</span></div>
  <div class="chip">Round <strong id="roundVal">1</strong> <span id="timeVal" class="badge">0:00</span></div>
  <div class="chip">Boss <span id="bossBadge" class="badge">‚Äî</span></div>
  <div class="chip">Energy
    <div class="bar"><i id="energyFill" style="width:0%"></i></div>
    <span id="energyNum" class="badge">0/10</span>
  </div>
  <div class="chip">HP
    <div class="bar"><i id="hpFill" style="width:100%"></i></div>
    <span id="hpNum" class="badge">100%</span>
  </div>
  <div class="chip">Enemy
    <div class="bar"><i id="ehpFill" style="width:100%"></i></div>
    <span id="ehpNum" class="badge">100%</span>
  </div>
  <div class="chip money">¬¢ <strong id="moneyVal">0</strong></div>
  <div class="chip"><span class="badge">1‚Äì5 or Click ‚Ä¢ Space deploy ‚Ä¢ P pause</span></div>
</div>

<!-- Bottom deploy bar -->
<div class="deploy" id="deployBar">
  <!-- filled by script -->
</div>

<!-- Title -->
<div id="title" class="overlay show">
  <div class="modal">
    <div class="row" style="justify-content:space-between;margin-bottom:8px">
      <div class="title">VOID WARS</div>
      <div class="row">
        <button id="openShopFromTitle" class="btn">‚õ≠ Upgrades</button>
        <button id="startBtn" class="btn primary">‚ñ∂ Start</button>
      </div>
    </div>
    <div class="list" style="gap:6px">
      <div class="row">
        <button class="btn small" data-diff="0">Easy</button>
        <button class="btn small primary" data-diff="1">Normal</button>
        <button class="btn small danger" data-diff="2">Hard</button>
      </div>
      <div class="row" style="gap:12px;align-items:center">
        <label class="row" style="gap:6px"><input id="optParticles" type="checkbox" checked/> Particles</label>
        <label class="row" style="gap:6px"><input id="optBloom" type="checkbox" checked/> Bloom</label>
        <label class="row" style="gap:6px"><input id="optShake" type="checkbox" checked/> Screen Shake</label>
        <label class="row" style="gap:6px"><input id="optSfx" type="checkbox" checked/> SFX</label>
        <span class="row" style="gap:6px">Volume <input id="optVol" type="range" min="0" max="1" step="0.01" value="0.6" style="width:180px"/></span>
      </div>
      <div class="badge">Tip: Every 5th round spawns a boss‚Äîdon‚Äôt let it reach your flagship.</div>
    </div>
  </div>
</div>

<!-- Shop -->
<div id="shop" class="overlay">
  <div class="modal">
    <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:6px">
      <div class="title">Upgrades (credits: <span id="shopCredits" class="money">0</span>)</div>
      <div class="row">
        <button id="toMenuFromShop" class="btn danger">‚éã Go to Menu</button>
      </div>
    </div>

    <div class="shop-grid" id="shopList"></div>

        <!-- NEW footer row -->
    <div class="row" style="margin-top:8px; justify-content:flex-end; gap:8px">
      <button id="shopNextBtn" class="btn primary">‚ñ∂ Next Battle</button>
    </div>


    <div class="badge" style="margin-top:8px">Prices increase: base √ó 1.25^level. Effects apply immediately.</div>
  </div>
</div>


<!-- Pause -->
<div id="pause" class="overlay">
  <div class="modal">
    <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:6px">
      <div class="title">Paused</div>
      <button id="resumeBtn" class="btn primary">Resume</button>
    </div>
    <div class="row">
      <button id="restartBtn" class="btn">‚Ü∫ Restart Round</button>
      <button id="toTitleBtn" class="btn danger">‚éã Quit to Title</button>
    </div>
  </div>
</div>

<!-- Game Over -->
<div id="gameover" class="overlay">
  <div class="modal">
    <div class="title" id="resultTitle">Battle Complete</div>
    <div class="list" style="margin:8px 0">
      <div id="statsText" class="badge">Stats‚Ä¶</div>
    </div>
    <div class="row">
      <button id="spendBtn" class="btn primary">‚õ≠ Spend Credits</button>
      <button id="nextBtn" class="btn">‚ñ∂ Next Round</button>
      <button id="quitBtn" class="btn danger">‚éã Quit to Title</button>
    </div>
  </div>
</div>

<div class="corner">
  <button id="speedBtn" class="btn small">‚è© Speed</button>
  <button id="helpBtn" class="btn small">‚ùî Help</button>
  <button id="shotBtn" class="btn small">üì∏</button>
  <button id="maxBtn" class="btn small">‚®â Max Deploy: Off</button>
</div>

<div id="toast" class="toast"></div>

<script>
(() => {
  "use strict";

  // ---------- Helpers ----------
  const clamp=(v,a,b)=>v<a?a:(v>b?b:v);
  const lerp=(a,b,t)=>a+(b-a)*t;
  const rand=(a,b)=>Math.random()*(b-a)+a;
  const randi=(a,b)=>Math.floor(rand(a,b));
  const TAU=Math.PI*2;
  // put near other helpers


  // ---------- Canvas ----------
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  function resize(){ cv.width=Math.floor(innerWidth*DPR); cv.height=Math.floor(innerHeight*DPR); }
  addEventListener('resize', resize); resize();

  // ---------- Audio (light) ----------
  let masterVol=0.6, audioCtx=null;
  function initAudio(){ if(audioCtx) return; try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch{} }
  function beep(freq=440,dur=.06,gain=.06,type='square'){
    if(!audioCtx || !Settings.sfx) return;
    const t=audioCtx.currentTime, o=audioCtx.createOscillator(), g=audioCtx.createGain();
    o.type=type; o.frequency.value=freq; g.gain.value=gain*masterVol;
    o.connect(g).connect(audioCtx.destination); o.start(t); o.stop(t+dur);
  }

  // ---------- Settings & State ----------
  const Settings = { particles:true, bloom:true, shake:true, sfx:true, difficulty:1 };
  const Speed = { mult:1, steps:[1,1.5,2] };
  const Player = {
    hpMax:15100, hp:15100, energy:30, energyMax:30, energyRegen:2.5, credits:0, // faster default regen
    upgrades:{
      dmg:0, hp:0, erg:0, cap:0, spd:0, armor:0, ram:0, projspd:0, range:0, squad:0, droneR:0, droneT:0, pd:0, aura:0, bossB:0, salvage:0
    }
  };
  const Enemy = {
    hpMax:15100, hp:15100, energy:30, energyMax:30, energyRegen:2.15,
    difficultyBias:1.0,
    specialUsed:false, personality:'balanced'
  };
  let Round=1, roundTime=0, nextBossIn=0, bossActive=false;
  let bossCleared=false;

  let paused=false, playing=false, gameOver=false;
  let LastOutcome = null; // 'win' | 'loss' | null


  // ---------- HUD ----------
  const $ = id=>document.getElementById(id);
  function toast(msg){ const t=$('toast'); t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),2000); }
  function setEnergyHUD(){ const f=Player.energy/Player.energyMax; $('energyFill').style.width=(f*100).toFixed(0)+'%'; $('energyNum').textContent=`${Math.floor(Player.energy)}/${Player.energyMax}`; }
  function setHPHUD(){ const r=Player.hp/Player.hpMax, rr=Enemy.hp/Enemy.hpMax; $('hpFill').style.width=(r*100).toFixed(0)+'%'; $('hpNum').textContent=`${Math.max(0,Math.floor(r*100))}%`; $('ehpFill').style.width=(rr*100).toFixed(0)+'%'; $('ehpNum').textContent=`${Math.max(0,Math.floor(rr*100))}%`; }
  function setMoneyHUD(){ $('moneyVal').textContent=Player.credits; $('shopCredits').textContent=Player.credits; }
  function setRoundHUD(){ $('roundVal').textContent=Round; }
  function setTimeHUD(){ const m=Math.floor(roundTime/60), s=Math.floor(roundTime%60).toString().padStart(2,'0'); $('timeVal').textContent=`${m}:${s}`; }
  function setBossHUD(){
    if (bossActive && boss){
      const p = Math.max(0, Math.floor((boss.hp / boss.hpMax) * 100));
      $('bossBadge').textContent = `HP ${p}%`;
    } else {
      $('bossBadge').textContent = (nextBossIn>0? `${Math.ceil(nextBossIn)}s` : '‚Äî');
    }
  }

  function setSpeedHUD(){ $('speedChip').textContent = Speed.mult.toFixed(2).replace(/\.00$/,'')+'√ó'; }

  // ---------- Background (stars) ----------
  const starsFar=[], starsNear=[];
  function seedStars(){
    starsFar.length=0; starsNear.length=0;
    const nFar=Math.floor((cv.width*cv.height)/(9000*DPR)), nNear=Math.floor((cv.width*cv.height)/(16000*DPR));
    for(let i=0;i<nFar;i++) starsFar.push({x:Math.random()*cv.width,y:Math.random()*cv.height,r:rand(.4,1),s:rand(.02,.05)});
    for(let i=0;i<nNear;i++) starsNear.push({x:Math.random()*cv.width,y:Math.random()*cv.height,r:rand(.7,1.8),s:rand(.05,.12)});
  }
  seedStars(); addEventListener('resize', seedStars);
  function drawBackground(dt){
    const g=ctx.createRadialGradient(cv.width*.5, cv.height*.35, 80, cv.width*.5, cv.height*.5, Math.max(cv.width,cv.height)*.9);
    g.addColorStop(0,"rgba(0,200,255,0.08)"); g.addColorStop(.45,"rgba(120,50,255,0.06)"); g.addColorStop(1,"rgba(0,0,0,0)");
    ctx.fillStyle=g; ctx.fillRect(0,0,cv.width,cv.height);
    ctx.globalCompositeOperation='lighter';
    ctx.fillStyle='#fff';
    for(const s of starsFar){ s.x+=s.s*dt*30; if(s.x>cv.width) s.x=0; ctx.globalAlpha=.35; ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,TAU); ctx.fill(); }
    for(const s of starsNear){ s.x+=s.s*dt*60; if(s.x>cv.width) s.x=0; ctx.globalAlpha=.8; ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,TAU); ctx.fill(); }
    ctx.globalAlpha=1; ctx.globalCompositeOperation='source-over';
  }

  // ---------- Particles ----------
  const parts=[];
  function spark(x,y,c="#aef",n=6,spd=1){ if(!Settings.particles) return;
    for(let i=0;i<n;i++) parts.push({x,y,vx:rand(-1,1)*spd,vy:rand(-1,1)*spd,t:0,life:rand(.3,.8),c});
  }
  function ringBlast(x,y,c="#fff",r=6){ if(!Settings.particles) return; parts.push({x,y,ring:1,r0:r,rv:90,t:0,life:.35,c});}
  function partsUpdate(dt){
    for(let i=parts.length-1;i>=0;i--){
      const p=parts[i]; p.t+=dt;
      if(p.ring){ p.r0+=p.rv*dt; if(p.t>p.life) parts.splice(i,1); continue; }
      p.x+=p.vx*dt*60; p.y+=p.vy*dt*60; p.vy+=.02*dt*60; if(p.t>p.life) parts.splice(i,1);
    }
  }
  function partsDraw(){
    if(!Settings.particles) return;
    ctx.globalCompositeOperation='lighter';
    for(const p of parts){
      if(p.ring){ ctx.globalAlpha=1-(p.t/p.life); ctx.strokeStyle=p.c; ctx.lineWidth=2*DPR; ctx.beginPath(); ctx.arc(p.x,p.y,p.r0,0,TAU); ctx.stroke(); continue; }
      const a=1-(p.t/p.life); ctx.globalAlpha=a; ctx.fillStyle=p.c; ctx.fillRect(p.x-1,p.y-1,2,2);
    }
    ctx.globalAlpha=1; ctx.globalCompositeOperation='source-over';
  }

  // ---------- Camera / Shake ----------
  const Cam={shake:0};
  function addShake(s=6){ if(Settings.shake) Cam.shake=Math.min(12,Cam.shake+s); }
  function applyCamera(){ let sx=0,sy=0; if(Cam.shake>0){ sx=rand(-Cam.shake,Cam.shake); sy=rand(-Cam.shake,Cam.shake); Cam.shake*=.9; if(Cam.shake<.2) Cam.shake=0; } ctx.setTransform(1,0,0,1,sx,sy); }
  function resetCamera(){ ctx.setTransform(1,0,0,1,0,0); }

  // ---------- Entities ----------
  const TEAM={ALLY:1, ENEMY:2};
  const TEAM_COLOR=t=>t===TEAM.ALLY?'#51d9ff':'#ff4d7a';
  const TYPE_ACCENT={ Fighter:"#70d7ff", Interceptor:"#6a8bff", Bomber:"#8be0ff", Drone:"#50ffa8", Frigate:"#ffd36b" };

  const BASE = {
    // Screen & brawl. Cheap, sturdy, real melee bite.
    Fighter:     {hp:80,  dmg:10, spd:135,  turn:3.3, cost:2, range:0,   mass:1.8, r:11, prefer:12,  sep:24},

    // Skirmisher. Fast ROF, decent range, glassier than Fighter.
    Interceptor: {hp:60,  dmg:9,  spd:210,  turn:2.6, cost:3, range:160, mass:1.2, r:12, prefer:110, sep:24,
                  rate:0.45, pspd:6.2},

    // Line breaker. Slow ROF, chunky hits, death boom (area denial).
    Bomber:      {hp:190, dmg:28, spd:95,   turn:1.8, cost:4, range:90,  mass:2.2, r:14, prefer:150, sep:26,
                  rate:1.00, pspd:5.0, boom:40, boomD:12},

    // Healer. Keeps teams alive; slight HP bump; longer med range.
    Drone:       {hp:85,  dmg:5,  spd:105,  turn:2.2, cost:3, range:130, mass:1.1, r:12, prefer:170, sep:28,
                  heal:14},

    // Backline artillery. Longest range, solid ROF, pricier.
    Frigate:     {hp:120, dmg:20, spd:98,   turn:2.0, cost:5, range:280, mass:1.7, r:13, prefer:230, sep:30,
                  rate:0.70, pspd:6.6},
  };


  const ORDER = ['Fighter','Interceptor','Bomber','Drone','Frigate'];
  // --- Collision tuning ---
  const MIN_REL_HIT = 0.6;         // ignore super-soft bumps
  const MAX_COLL_DMG = 14;         // hard cap per collision tick
  const COLLISION_SCALE = {        // type-specific incoming-collision scaling
    Fighter: 0.25,
    Interceptor: 0.45,
    Bomber: 0.70,
    Drone: 0.40,
    Frigate: 0.65
  };

  const FIGHTER_MELEE_DPS_MULT = 0.6;   // ~ (1.2 hit) / (0.22s) ‚âà 5.45√ó dmg/sec
  const FIGHTER_MELEE_PAD = 2;
  
  
  const ships=[], shots=[], heals=[];
  let boss=null;

  // Flagships (collidable)
  const Flag = {
    ally:{x:140, y:cv.height*0.5, w:28, h:240, team:TEAM.ALLY},
    enemy:{x:cv.width-140, y:cv.height*0.5, w:28, h:240, team:TEAM.ENEMY}
  };
  addEventListener('resize', ()=>{
    Flag.ally.y = cv.height*0.5; Flag.enemy.x = cv.width-140; Flag.enemy.y = cv.height*0.5;
  });

  // ---------- Shop (progressive prices) ----------
  const UPG = [
    {key:'dmg',    name:'Weapon Damage',  desc:'+10% ship damage', base:120, per:0.10},
    {key:'hp',     name:'Hull Plating',  desc:'+12% max HP',      base:120, per:0.12},
    {key:'erg',    name:'Reactor Regen', desc:'+15% energy regen',base:140, per:0.15},
    {key:'cap',    name:'Energy Cap',    desc:'+2 max energy',    base:160, flat:2},
    {key:'spd',    name:'Thrusters',     desc:'+10% ship speed',  base:110, per:0.10},
    {key:'armor',  name:'Armor',         desc:'-8% incoming dmg', base:140, per:0.08},
    {key:'ram',    name:'Ramming Plate', desc:'+25% collision dmg',base:130, per:0.25},
    {key:'projspd',name:'Projectile Spd',desc:'+15% projectile speed',base:120, per:0.15},
    {key:'range',  name:'Targeting Suite',desc:'+10% weapon range',base:120, per:0.10},
    {key:'squad',  name:'Squad Size',    desc:'+1 concurrent unit',base:200, flat:1},
    {key:'droneR', name:'Drone Optics',  desc:'+15% heal range',  base:110, per:0.15},
    {key:'droneT', name:'Med Throughput',desc:'+20% heal/sec',    base:130, per:0.20},
    {key:'pd',     name:'Point-Defense', desc:'Flagship auto-turret',base:220, flat:1},
    {key:'aura',   name:'Captain‚Äôs Tactics',desc:'+5% global aura',base:180, per:0.05},
    {key:'bossB',  name:'Boss Buster',   desc:'+20% vs bosses',   base:180, per:0.20},
    {key:'salvage',name:'Salvage Bonus', desc:'+4c on kill',      base:140, flat:1},
  ];
  function upgCost(key){ const base = UPG.find(u=>u.key===key).base; const lvl=Player.upgrades[key]||0; return Math.floor(base*Math.pow(1.25,lvl)); }

  function applyStats(){
    Player.energyMax = 30 + (Player.upgrades.cap||0)*2;
    Player.energyRegen = 6.0*(1+(Player.upgrades.erg||0)*0.15); // faster base (2.0)
    Player.hpMax = Math.floor(1100*(1+(Player.upgrades.hp||0)*0.12));
    Player.hp = clamp(Player.hp,0,Player.hpMax);
  }

  // ---------- Spawning ----------
  const Selected={type:'Fighter'};
  const typeCooldown = {Fighter:0, Interceptor:0, Bomber:0, Drone:0, Frigate:0};
  const typeCDLen = {Fighter:0.2, Interceptor:0.5, Bomber:1.0, Drone:1.0, Frigate:1.2};
  for (const k in typeCDLen) typeCDLen[k] /= 2;  // global 3√ó faster spawns

  let concurrentLimit=1;
  function canAfford(type){ return Player.energy >= BASE[type].cost; }

  // Max deploy mode
  const Modes = { maxDeploy:false };

  function tryDeploy(type, team=TEAM.ALLY){
    if(!playing || paused) return false;

    // cooldown gate for single spawn; allow batch to bypass initial gate
    if(team===TEAM.ALLY && typeCooldown[type]>0 && !Modes.maxDeploy) return false;

    const countAllies = () => ships.filter(s=>s.team===TEAM.ALLY).length;

    if(team===TEAM.ALLY && !canAfford(type)) return false;
    // no cap anymore
    const cost = BASE[type].cost;  // <‚Äî needed by both paths below


    // Batch deploy in max mode
    if(team===TEAM.ALLY && Modes.maxDeploy){
      let spawned=0;
      while(Player.energy>=cost){                // no cap check
        Player.energy-=cost;
        spawnShip(type,team);
        spawned++;
        if(spawned>400) break; // relaxed safety
      }

      setEnergyHUD();
      typeCooldown[type]=typeCDLen[type]; // standard cooldown after burst
      return spawned>0;
    }

    // Single spawn
    if(team===TEAM.ALLY){
      Player.energy-=cost; setEnergyHUD(); typeCooldown[type]=typeCDLen[type];
    }
    spawnShip(type,team);
    return true;
  }

  // ---------- Ship factory ----------
  function spawnShip(type,team){
    const b=BASE[type], aura=1+(Player.upgrades.aura||0)*0.05;
    const s={
      id:Math.random().toString(36).slice(2),
      type, team,
      x: team===TEAM.ALLY ? Flag.ally.x+50 : Flag.enemy.x-50,
      y: team===TEAM.ALLY ? Flag.ally.y+rand(-120,120) : Flag.enemy.y+rand(-120,120),
      vx:0, vy:0, ang:0,
      hp:Math.floor(b.hp * (1+(Player.upgrades.hp||0)*0.12) * aura),
      hpMax:0, r:b.r, mass:b.mass,
      target:null, cd:0, ranged:b.range>0,
      maxSpd:b.spd*(1+(Player.upgrades.spd||0)*0.10)*aura,
      turn:b.turn, range:b.range*(1+(Player.upgrades.range||0)*0.10),
      dmg:Math.floor(b.dmg * (1+(Player.upgrades.dmg||0)*0.10) * aura),
      healPS: b.heal ? b.heal*(1+(Player.upgrades.droneT||0)*0.20) : 0,
      boom: b.boom||0, boomD:b.boomD||0, proj:b.proj||0,
      rate: b.rate ?? 1.0,
      pspd: b.pspd ?? 5.0,


      // NEW
      meleeCD: 0,
    };

    s.hpMax=s.hp;
    // personality from BASE
    s.prefer = b.prefer || 90;   // desired distance to target
    s.sep    = b.sep || 26;      // separation radius from allies

    // drones should heal, not count as "ranged shooter"
    if (type === 'Drone') s.ranged = false;

    ships.push(s);
    spark(s.x,s.y,TEAM_COLOR(team),10,1.2);
    beep(team===TEAM.ALLY?540:500,.05,.05,'sawtooth');
    return s;
  }

  // ---------- Shooting ----------
  function fire(from, tx, ty, speed=5){
    const a=Math.atan2(ty-from.y, tx-from.x);
    const v=speed*(1+(Player.upgrades.projspd||0)*0.15);
    const spd = from.team===TEAM.ALLY? v : v*1.0;
    shots.push({x:from.x,y:from.y,vx:Math.cos(a)*spd,vy:Math.sin(a)*spd,team:from.team,dmg:from.dmg,life:2.5, r:3});
    spark(from.x,from.y,TEAM_COLOR(from.team),4,.6);
    beep(from.team===TEAM.ALLY?780:700,.04,.04,'square');
  }

  // ---------- Collision Helpers ----------
  function rectCircle(rx,ry,rw,rh,cx,cy,cr){
    const tx=clamp(cx,rx,rx+rw), ty=clamp(cy,ry,ry+rh), dx=cx-tx, dy=cy-ty; return dx*dx+dy*dy<=cr*cr;
  }

  // ---------- Steering ----------
  function steer(s, dt){
    let tgt=null, best=Infinity;
    for(const o of ships){
      if(o.team!==s.team){
        const d = Math.hypot(o.x-s.x,o.y-s.y);
        const ttk = (o.hp / Math.max(1,s.dmg)) + d/100;
        if(ttk<best){ best=ttk; tgt=o; }
      }
    }
    const foeF = (s.team===TEAM.ALLY
      ? (bossActive && boss ? boss : Flag.enemy)
      : Flag.ally);

    const dxF = foeF.x - s.x, dyF = foeF.y - s.y, dF = Math.hypot(dxF,dyF);
    if(!tgt || dF<best*0.9) tgt = foeF;

    let desireX=0, desireY=0;

    // SEEK / ARRIVE
    if(tgt){
      const tx = ('w' in tgt) ? tgt.x : tgt.x, ty = ('w' in tgt) ? tgt.y : tgt.y;
      let dx = tx - s.x, dy = ty - s.y, d = Math.hypot(dx,dy)||1;
      const arrive = s.prefer || 90;
      const m = (d<arrive)? lerp(0, s.maxSpd, d/arrive) : s.maxSpd;
      desireX += (dx/d) * m; desireY += (dy/d) * m;
    }

    // KITE for frigates
    if (s.type==='Frigate' && tgt && !('w' in tgt)){
      const dx = tgt.x - s.x, dy = tgt.y - s.y, d=Math.hypot(dx,dy)||1;
      const keep = Math.max(s.range*0.75, s.prefer);
      if (d < keep){ desireX -= (dx/d)*s.maxSpd*.8; desireY -= (dy/d)*s.maxSpd*.8; }
    }


    // SEPARATION
    // SEPARATION (only from allies so we can stick to enemies)
    let sepX=0, sepY=0, count=0;
    for(const o of ships){
      if(o===s || o.team!==s.team) continue; // <‚Äî only allies
      const dx=o.x-s.x, dy=o.y-s.y, d=Math.hypot(dx,dy)||1;
      if (d < s.sep) { sepX -= dx/d; sepY -= dy/d; count++; } // a bit tighter than 28
    }
    if(count>0){ const k=1.2*s.maxSpd; desireX += (sepX/count)*k; desireY += (sepY/count)*k; }


    // AVOID FLAGSHIPS (unless ramming)
    const foe = (s.team===TEAM.ALLY? Flag.enemy : Flag.ally);
    if(!('w' in tgt)){
      const rx=foe.x-foe.w/2, ry=foe.y-foe.h/2;
      if(rectCircle(rx,ry,foe.w,foe.h,s.x,s.y, s.r+8)){
        const dx = (s.x-foe.x)||1, dy=(s.y-foe.y)||0, d=Math.hypot(dx,dy)||1;
        desireX += (dx/d)*s.maxSpd*1.2; desireY += (dy/d)*s.maxSpd*1.2;
      }
    }

    // UPDATE velocity
    const accX = desireX - s.vx, accY = desireY - s.vy;
    const accMax = 0.15 * 60;
    const aLen = Math.hypot(accX,accY)||1;
    const ax = accX/aLen * Math.min(accMax, aLen);
    const ay = accY/aLen * Math.min(accMax, aLen);
    s.vx += ax*dt*60; s.vy += ay*dt*60;

    const sp = Math.hypot(s.vx,s.vy);
    const max = s.maxSpd*60;
    if(sp>max){ s.vx = s.vx/sp*max; s.vy=s.vy/sp*max; }

    s.vx += rand(-.02,.02)*60*dt; s.vy += rand(-.02,.02)*60*dt;

    s.x += s.vx*dt; s.y += s.vy*dt;
    s.y = clamp(s.y, 40, cv.height-40);
  }

  // ---------- Damage ----------
  function applyDamage(target, amount, sourceTeam){
    if(amount<=0) return;

    const armor= (target.team===TEAM.ALLY? Player.upgrades.armor||0 : 0);
    const scale = target.team===TEAM.ALLY ? (1-armor*0.08) : 1;
    let amt = Math.max(1, Math.floor(amount*scale));

    if(boss && target===boss && (sourceTeam===TEAM.ALLY)){
      amt = Math.floor(amt*(1+(Player.upgrades.bossB||0)*0.20));
    }

    // Redirect flagship damage to pools (prevents mirror from overwriting)
    if(target === Flag.enemy){ Enemy.hp = Math.max(0, Enemy.hp - amt); return; }
    if(target === Flag.ally){ Player.hp = Math.max(0, Player.hp - amt); return; }

    target.hp -= amt;
  }

  // ---------- Updates ----------
  function updateShips(dt){
    for(const k in typeCooldown){ typeCooldown[k]=Math.max(0, typeCooldown[k]-dt); updateDeployCD(k); }
    heals.length=0;

    for(let i=ships.length-1;i>=0;i--){
      const s=ships[i];
        // Safe: works even if s.meleeCD was never defined
        
        
      steer(s,dt);
      
        // --- RELIABLE FIGHTER MELEE DPS ON CONTACT ---
      if (s.type === 'Fighter') {
        // Find any *one* enemy touching us (closest first)
        let victim = null, best = Infinity;
        for (const o of ships) {
          if (o.team === s.team) continue;
          const d = Math.hypot(o.x - s.x, o.y - s.y);
          const FIGHTER_MELEE_RANGE = 26; // damage when within ~26px, not just overlap
          if (d < Math.max(FIGHTER_MELEE_RANGE, s.r + o.r + FIGHTER_MELEE_PAD) && d < best) {
            best = d; victim = o;
          }
        }
        if (victim) {
          // Apply continuous DPS so sliding/side-jitter still deals damage
          const dps = s.dmg * FIGHTER_MELEE_DPS_MULT; // scales with upgrades (uses s.dmg)
          applyDamage(victim, dps * dt, s.team);
          // (optional) tiny spark for feedback
          if (Math.random() < 0.12) spark((s.x+victim.x)/2, (s.y+victim.y)/2, '#fff', 4, 0.8);
        }
      }


      s.meleeCD = Math.max(0, (s.meleeCD || 0) - dt);

      // firing / melee
      s.cd -= dt;
      if(s.type==='Fighter'){ /* melee via collisions */ }
      else if(s.ranged){
        let tgt=null, best=Infinity;
        for(const o of ships){ if(o.team!==s.team){
          const d = Math.hypot(o.x-s.x,o.y-s.y); if(d<best){best=d; tgt=o;}
        }}
        const foeF = (s.team===TEAM.ALLY? Flag.enemy:Flag.ally);
        const dF = Math.abs(foeF.x - s.x);
        if(!tgt || dF<best) tgt=foeF;

        const dx = (('w' in tgt)? tgt.x - s.x : tgt.x - s.x);
        const dy = (('w' in tgt)? tgt.y - s.y : tgt.y - s.y);
        const dist = Math.hypot(dx,dy);
        if(dist < s.range && s.cd<=0){
          s.cd = s.rate;
          fire(s, s.x+dx, s.y+dy, s.pspd);
        }

      } else if(s.type==='Drone'){
        let best=null, br=Infinity;
        const r = (BASE.Drone.range*(1+(Player.upgrades.droneR||0)*0.15));
        for(const o of ships){ if(o.team===s.team && o!==s && o.hp<o.hpMax){
          const d=Math.hypot(o.x-s.x,o.y-s.y); if(d<r && o.hp/o.hpMax < br){ br=o.hp/o.hpMax; best=o; }
        }}
        if(best){
          heals.push({x1:s.x,y1:s.y,x2:best.x,y2:best.y,t:0});
          best.hp = Math.min(best.hpMax, best.hp + s.healPS*1.5*dt); // 1.5√ó stronger
          if(Math.random()<.2) spark(best.x,best.y,'#aef',2,.3);
        }
      }

      if(s.hp<=0){
        if(s.boom){
          ringBlast(s.x,s.y,TEAM_COLOR(s.team), 10);
          for(const o of ships){ if(o.team!==s.team && Math.hypot(o.x-s.x,o.y-s.y) < s.boom){ applyDamage(o, s.boomD, s.team); } }
          addShake(8);
        }
        if(s.team===TEAM.ENEMY && (Player.upgrades.salvage||0)>0){
          Player.credits += 4*(Player.upgrades.salvage||0); setMoneyHUD();
        }
        spark(s.x,s.y,TEAM_COLOR(s.team),14,1.6); beep(160,.06,.06,'triangle');
        ships.splice(i,1);
      }
    }
  }

  function collisions(dt){
    // ship<->ship circles
    for(let i=0;i<ships.length;i++){
      const a=ships[i];
      for(let j=i+1;j<ships.length;j++){
        const b=ships[j];
        const dx=b.x-a.x, dy=b.y-a.y; 
        const dist=Math.hypot(dx,dy);
        const min = a.r + b.r;

        if(dist<min){
          const nx = dx/(dist||1), ny = dy/(dist||1);
          const overlap = (min - dist);

          // separate
          a.x -= nx*overlap*.5; a.y -= ny*overlap*.5;
          b.x += nx*overlap*.5; b.y += ny*overlap*.5;

          // physics impact calc
          const rel = Math.abs((b.vx-a.vx)*nx + (b.vy-a.vy)*ny);
          const base = 0.05 * (a.mass + b.mass) * rel * (Player.upgrades.ram ? 1 + Player.upgrades.ram*0.25 : 1);

          if (a.team !== b.team) {
  // -------- MASS-WEIGHTED PUSH + LOW CHIP DAMAGE --------
  // rel = relative speed along the collision normal (already computed above)

  // Tuning knobs (all local; tweak here if needed)
  const RESTITUTION    = 0.20;   // 0 = sticky, 1 = super bouncy
  const PUSH_GAIN      = 20.0;   // overall push strength
  const PUSH_CAP       = 60.0;   // cap the push so it doesn't explode apart
  const DMG_PER_IMPULSE= 0.11;   // convert push impulse to damage (low = chip)
  const DMG_CAP        = 12.0;   // max damage per collision tick

  // Effective mass for a 1D collision impulse (heavier ships impart/absorb more)
  const mA = Math.max(0.1, a.mass), mB = Math.max(0.1, b.mass);
  const mEff = (mA * mB) / (mA + mB);

  // Base impulse along the normal (mass-weighted), includes a touch of restitution
  let J = (rel * (1 + RESTITUTION)) * mEff * PUSH_GAIN * (Player.upgrades.ram ? (1 + Player.upgrades.ram*0.25) : 1);
  J = Math.min(J, PUSH_CAP);

  // Apply equal & opposite impulses; heavy ships move less for the same impulse
  a.vx -= nx * (J / mA); a.vy -= ny * (J / mA);
  b.vx += nx * (J / mB); b.vy += ny * (J / mB);

  // Low chip damage based on impulse; scale by *opponent* mass so heavier hitters hurt more
  const dmgToB = Math.min(DMG_CAP, J * DMG_PER_IMPULSE * (mA / 1.5));
  const dmgToA = Math.min(DMG_CAP, J * DMG_PER_IMPULSE * (mB / 1.5));

  if (dmgToB > 0.25) applyDamage(b, dmgToB, a.team);
  if (dmgToA > 0.25) applyDamage(a, dmgToA, b.team);

  // (Keep your Fighter melee/DPS-on-contact code right after this if you have it)
}


        }
      }

      // ship with enemy flagship
      // ship with enemy flagship
// During boss: allies ignore enemy flagship (they fight the boss).
if (!bossActive || a.team !== TEAM.ALLY) {
    const foeF = (a.team===TEAM.ALLY? Flag.enemy : Flag.ally);
    const rx=foeF.x-foeF.w/2, ry=foeF.y-foeF.h/2;
    if(rectCircle(rx,ry,foeF.w,foeF.h,a.x,a.y,a.r)){
      const dir = Math.sign(a.x-foeF.x)||1;
      a.vx += dir*60*dt; a.x += dir*14;

      const vsFlagScale = (a.type==='Fighter' ? 0.35 : 0.8);
      applyDamage(foeF, a.mass*8 * vsFlagScale, a.team);
      applyDamage(a,    a.mass*9 * vsFlagScale, foeF.team);

      spark(a.x,a.y,TEAM_COLOR(a.team),8,1.2); addShake(4);
    }
  }

      // --- ship ‚Üî boss (circle-circle)
if (boss && a.team === TEAM.ALLY){
  const dx = a.x - boss.x,  dy = a.y - boss.y;
  const dist = Math.hypot(dx,dy);
  const minD = a.r + boss.r;
  if (dist < minD){
    const nx = dx/(dist||1), ny = dy/(dist||1);
    const overlap = (minD - dist);
    a.x += nx*overlap*0.85; a.y += ny*overlap*0.85;
    boss.x -= nx*overlap*0.15; boss.y -= ny*overlap*0.15;

    const rel = Math.abs(a.vx*nx + a.vy*ny);
    const J = Math.min(50, rel * (a.mass+3));
    a.vx += nx * (J / Math.max(0.6,a.mass));
    a.vy += ny * (J / Math.max(0.6,a.mass));

    applyDamage(a,    5 + a.mass*1.5, TEAM.ENEMY);
    applyDamage(boss, 3 + a.mass*1.2, a.team);

    spark(a.x,a.y,'#ff9ab3',8,1.2);
    addShake(3);
  }
}

// --- boss ‚Üî ally flagship
if (boss){
  const rxA = Flag.ally.x-Flag.ally.w/2, ryA = Flag.ally.y-Flag.ally.h/2;
  if (rectCircle(rxA, ryA, Flag.ally.w, Flag.ally.h, boss.x, boss.y, boss.r)){
    applyDamage(Flag.ally, 10, TEAM.ENEMY);
    boss.x += 6*dt*60; // gentle nudge
  }
}

    }

    // shots
    for(let i=shots.length-1;i>=0;i--){
      const b=shots[i]; b.x+=b.vx*dt*60; b.y+=b.vy*dt*60; b.life-=dt;
      if(b.life<=0){ shots.splice(i,1); continue; }

      // ship hit
      let hit=false;
      for(const s of ships){ if(s.team!==b.team){
        if(Math.hypot(s.x-b.x,s.y-b.y) < s.r + b.r){
          applyDamage(s, b.dmg, b.team); hit=true; spark(b.x,b.y,TEAM_COLOR(b.team),6,1.0); break;
        }
      }}

        // boss hit
      if(!hit && boss){
        if(Math.hypot(b.x-boss.x, b.y-boss.y) < boss.r + b.r){
          applyDamage(boss, b.dmg, b.team);
          hit=true;
          spark(b.x,b.y,'#ff9ab3',6,1.0);
          addShake(1);
        }
      }


      // flagship hit
    // During boss: ally bullets ignore enemy flagship (they hit boss instead).
    if (!hit && (!bossActive || b.team !== TEAM.ALLY)) {
      const foeF = (b.team===TEAM.ALLY? Flag.enemy : Flag.ally);
      const rx=foeF.x-foeF.w/2, ry=foeF.y-foeF.h/2;
      if(rectCircle(rx,ry,foeF.w,foeF.h,b.x,b.y,6)){
        hit=true; applyDamage(foeF, Math.floor(b.dmg*1.2), b.team); addShake(4);
      }
    }


      if(hit){ shots.splice(i,1); }
      else if(b.x<-40||b.x>cv.width+40||b.y<-40||b.y>cv.height+40){ shots.splice(i,1); }
    }
  }

  // ---------- Boss ----------
  // ---------- Boss (ALIEN UFO) ----------
// ---------- Boss ----------
// ---------- Boss (Alien Mind: stationary, collidable circle, no minions) ----------
// ---------- Boss (Alien Mind: circular, visible, attacks) ----------
function spawnBoss(){
  bossActive = true;
  Enemy.specialUsed = false;

  // don't wipe; just pause enemy spawns a moment via AI cadence (handled by aiTick surge schedule)
  // optionally trim a few enemies if field is overcrowded
  let enemies = ships.filter(s=>s.team===TEAM.ENEMY);
  if (enemies.length>22){
    // remove a few furthest from ally flagship to make space
    enemies.sort((a,b)=> (Math.abs(b.x-Flag.ally.x)-Math.abs(a.x-Flag.ally.x)));
    const cut = enemies.slice(0, Math.min(6, enemies.length-18));
    ships.splice(0, ships.length, ...ships.filter(s=>!cut.includes(s)));
  }

  boss = {
    type: 'ophanim',
    x: Flag.enemy.x,
    y: Flag.enemy.y,
    r: 60,
    hp: Math.floor(2400*(1+Round*0.28)),
    hpMax: 0,
    team: TEAM.ENEMY,
    t: 0,
    phase: 1, pt: 0,
    sweep: 0,
    rings: [
      {rad: 70,  speed: +0.9,  eyes: 10, rot: 0},
      {rad: 105, speed: -0.6,  eyes: 14, rot: 0},
      {rad: 140, speed: +0.35, eyes: 18, rot: 0}
    ],
    shotCD: 0, sweepCD: 2.5, crossCD: 7, summonCD: 8.5,
    blinkSeed: Math.random()*1000,
  };
  boss.hpMax = boss.hp;

  toast('‚ö† The Ophanim descends‚Ä¶');
  setBossHUD();
}



function bossBolt(angle, speed=6.0, dmg=14, life=3.0){
  const v = speed;
  shots.push({
    x: boss.x + Math.cos(angle)*(boss.r+4),
    y: boss.y + Math.sin(angle)*(boss.r+4),
    vx: Math.cos(angle)*v,
    vy: Math.sin(angle)*v,
    team: TEAM.ENEMY,
    dmg, life, r:3
  });
  spark(boss.x, boss.y, '#ff9ab3', 6, 1.0);
}

function updateBoss(dt){
  if (!boss) return;
  boss.t += dt; boss.pt += dt;

  // phase transitions
  if (boss.phase===1 && boss.hp<boss.hpMax*0.66){ boss.phase=2; boss.pt=0; addShake(6); }
  if (boss.phase===2 && boss.hp<boss.hpMax*0.33){ boss.phase=3; boss.pt=0; addShake(8); }

  // hover
  boss.y += Math.sin(boss.t*0.8)*0.25*dt*60;

  // rotate rings
  for (const r of boss.rings) r.rot += r.speed*dt*(boss.hp<boss.hpMax*0.25?1.3:1.0);

  // cooldowns
  boss.shotCD   = Math.max(0,boss.shotCD   - dt);
  boss.sweepCD  = Math.max(0,boss.sweepCD  - dt);
  boss.crossCD  = Math.max(0,boss.crossCD  - dt);
  boss.summonCD = Math.max(0,boss.summonCD - dt);

  // (A) Gaze Barrage: ring eye darts toward ally flagship
  if (boss.shotCD<=0){
    boss.shotCD = 0.18;
    const ring = boss.rings[(Math.random()*boss.rings.length)|0];
    const idx  = (Math.random()*ring.eyes)|0;
    const a = ring.rot + idx*(TAU/ring.eyes);
    const ox = boss.x + Math.cos(a)*ring.rad;
    const oy = boss.y + Math.sin(a)*ring.rad;
    const ang = Math.atan2(Flag.ally.y-oy, Flag.ally.x-ox);
    shots.push({x:ox,y:oy,vx:Math.cos(ang)*7.6,vy:Math.sin(ang)*7.6,team:TEAM.ENEMY,dmg:14+(boss.phase*3),life:2.8,r:3});
    if (Math.random()<0.1) spark(ox,oy,'#ffd36b',6,1.0);
  }

  // (B) Sweeping Wheel: a wide arc that damages allies along the ring band
  if (boss.sweepCD<=0){
    boss.sweepCD = (boss.phase>=2 ? 3.4 : 4.8);
    boss.sweep   = (boss.sweep+TAU/3)%TAU;
    addShake(6);
  }
  const sweepRing = boss.rings[1];
  const sweepWidth = (boss.phase>=2 ? 0.45 : 0.35);
  const sweepSpeed = (boss.phase>=2 ? 0.9  : 0.7 );
  boss.sweep += sweepSpeed*dt;
  const sa = boss.sweep, sb = sa+sweepWidth;
  for (const s of ships){
    if (s.team!==TEAM.ALLY) continue;
    const dx=s.x-boss.x, dy=s.y-boss.y; const a=Math.atan2(dy,dx);
    const norm=(x)=> (x+TAU)%TAU, A=norm(a), S=norm(sa), E=norm(sb);
    const inside = S<E ? (A>=S && A<=E) : (A>=S || A<=E);
    const d = Math.hypot(dx,dy);
    if (inside && d> (s.r+10) && d < sweepRing.rad+34){
      applyDamage(s, (18+boss.phase*6)*dt, TEAM.ENEMY);
      if (Math.random()<0.2) spark(s.x,s.y,'#ff9ab3',4,0.7);
    }
  }

  // (C) Judgment Cross: two perpendicular beams
  if (boss.crossCD<=0){
    boss.crossCD = (boss.phase>=3 ? 6.2 : 7.8);
    addShake(8);
    for (let i=0;i<2;i++){
      const ang = boss.t*0.7 + i*Math.PI/2;
      const dx=Math.cos(ang), dy=Math.sin(ang);
      for (const s of ships){
        if (s.team!==TEAM.ALLY) continue;
        const relx=s.x-boss.x, rely=s.y-boss.y;
        const proj = relx*dx + rely*dy;
        if (proj>0 && Math.abs(relx*dy-rely*dx)<26){
          applyDamage(s, 38*dt, TEAM.ENEMY);
        }
      }
    }
  }

  // (D) Summon Choir: escorts
  if (boss.phase>=2 && boss.summonCD<=0){
    boss.summonCD = 7.2;
    for (let i=0;i<3+(boss.phase-2);i++){
      spawnShip(Math.random()<0.5?'Interceptor':'Fighter', TEAM.ENEMY);
    }
    for (let k=0;k<20;k++) spark(boss.x,boss.y,'#ffe7aa', 1, 0.5);
    addShake(7);
  }

  // collision with ally flagship
  const rx=Flag.ally.x-Flag.ally.w/2, ry=Flag.ally.y-Flag.ally.h/2;
  if (rectCircle(rx,ry,Flag.ally.w,Flag.ally.h,boss.x,boss.y,boss.r)){
    applyDamage(Flag.ally, 8*dt, TEAM.ENEMY);
  }
}


function drawBoss(){
  if (!boss) return;
  const hpFrac = Math.max(0,boss.hp/boss.hpMax);
  const pulse  = 0.5 + 0.5*Math.sin(boss.t*2.2);

  // Outer aura
  const auraR = boss.r + 34 + 18*(1-hpFrac);
  const g = ctx.createRadialGradient(boss.x,boss.y, boss.r*0.3, boss.x,boss.y, auraR);
  g.addColorStop(0, 'rgba(255,211,107,0.20)');
  g.addColorStop(1, 'rgba(255,74,122,0.00)');
  ctx.fillStyle = g; ctx.beginPath(); ctx.arc(boss.x,boss.y,auraR,0,TAU); ctx.fill();

  // Core halo arcs
  for (let h=0; h<3; h++){
    ctx.strokeStyle = 'rgba(255,211,107,0.5)';
    ctx.lineWidth = (h===1? 2.5:1.5)*DPR;
    const rr = boss.r + 28 + h*14;
    const a0 = boss.t*0.5 + h*0.7;
    ctx.beginPath(); ctx.arc(boss.x,boss.y, rr, a0, a0+TAU*0.6); ctx.stroke();
  }

  // Core eye (iris + pupil)
  ctx.lineWidth = 3*DPR; ctx.strokeStyle = '#ffd36b';
  ctx.beginPath(); ctx.arc(boss.x,boss.y,boss.r,0,TAU); ctx.stroke();
  ctx.fillStyle = 'rgba(255,231,200,0.8)';
  ctx.beginPath(); ctx.arc(boss.x,boss.y,boss.r*0.55 + 2*Math.sin(boss.t*3),0,TAU); ctx.fill();

  // Charging pupil
  const charging = (boss.crossCD<1.0? 1-boss.crossCD : 0);
  ctx.fillStyle = `rgba(255,77,122,${0.6+0.4*charging})`;
  ctx.beginPath(); ctx.arc(boss.x,boss.y,boss.r*0.28*(1-0.4*charging),0,TAU); ctx.fill();

  // Rings with many eyes (ophanim)
  for (let ri=0; ri<boss.rings.length; ri++){
    const ring = boss.rings[ri];
    const rr = ring.rad;

    // ring outline
    ctx.strokeStyle = 'rgba(255,158,196,0.65)';
    ctx.lineWidth = 2*DPR;
    ctx.beginPath(); ctx.arc(boss.x,boss.y, rr, 0, TAU); ctx.stroke();

    // eyes
    for (let i=0; i<ring.eyes; i++){
      const eyeA = ring.rot + i*(TAU/ring.eyes);
      const ex = boss.x + Math.cos(eyeA)*rr;
      const ey = boss.y + Math.sin(eyeA)*rr;

      // blink
      const blink = 0.25 + 0.75*Math.abs(Math.sin(boss.blinkSeed + boss.t*2.3 + i*0.6 + ri));
      const size = 8 + (ri*1.3);
      const h = size * (0.5 + 0.5*blink);

      // glow
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = 'rgba(255,236,200,0.7)';
      ctx.beginPath(); ctx.ellipse(ex,ey, size+2, h+2, eyeA, 0, TAU); ctx.fill();
      ctx.globalAlpha = 1;

      // outline
      ctx.strokeStyle = '#ffd36b';
      ctx.lineWidth = 1.5*DPR;
      ctx.beginPath(); ctx.ellipse(ex,ey, size, h, eyeA, 0, TAU); ctx.stroke();

      // pupil slit aimed at ally flagship
      const aim = Math.atan2(Flag.ally.y-ey, Flag.ally.x-ex);
      ctx.strokeStyle = '#ff4d7a';
      ctx.beginPath();
      ctx.moveTo(ex + Math.cos(aim+Math.PI/2)* (h*0.5), ey + Math.sin(aim+Math.PI/2)* (h*0.5));
      ctx.lineTo(ex - Math.cos(aim+Math.PI/2)* (h*0.5), ey - Math.sin(aim+Math.PI/2)* (h*0.5));
      ctx.stroke();
    }
  }

  // Sweeping beam visual (ring[1])
  if (boss.sweepCD > 0.2){
    const ring = boss.rings[1], rr = ring.rad;
    const w = (boss.phase>=2 ? 0.45 : 0.35);
    const sa = boss.sweep, sb = sa+w;
    ctx.strokeStyle = 'rgba(255,102,140,0.6)';
    ctx.lineWidth = 10*DPR;
    ctx.beginPath(); ctx.arc(boss.x,boss.y, rr, sa, sb); ctx.stroke();
    ctx.strokeStyle = 'rgba(255,255,255,0.7)';
    ctx.lineWidth = 3*DPR; ctx.beginPath(); ctx.arc(boss.x,boss.y, rr, sa, sb); ctx.stroke();
  }

  // Cross-beam charge cue
  if (boss.crossCD<1.0){
    const intensity = 1 - boss.crossCD;
    for (let i=0;i<2;i++){
      const ang = boss.t*0.7 + i*Math.PI/2;
      ctx.strokeStyle = `rgba(255,233,200,${0.35+0.4*intensity})`;
      ctx.lineWidth = (6+10*intensity)*DPR;
      ctx.beginPath();
      ctx.moveTo(boss.x - Math.cos(ang)*1600, boss.y - Math.sin(ang)*1600);
      ctx.lineTo(boss.x + Math.cos(ang)*1600, boss.y + Math.sin(ang)*1600);
      ctx.stroke();

      ctx.strokeStyle = 'rgba(255,90,130,0.9)';
      ctx.lineWidth = (2+5*intensity)*DPR;
      ctx.beginPath();
      ctx.moveTo(boss.x - Math.cos(ang)*1600, boss.y - Math.sin(ang)*1600);
      ctx.lineTo(boss.x + Math.cos(ang)*1600, boss.y + Math.sin(ang)*1600);
      ctx.stroke();
    }
  }

  // Low-HP flicker
  if (hpFrac<0.25){ ctx.globalAlpha = 0.9 + 0.1*Math.sin(boss.t*18); } else { ctx.globalAlpha = 1; }

  // HP ring
  const frac=Math.max(0,boss.hp/boss.hpMax);
  ctx.strokeStyle='#ff4d7a'; ctx.lineWidth=4*DPR;
  ctx.beginPath(); ctx.arc(boss.x,boss.y,boss.r+26,-Math.PI*0.8,-Math.PI*0.8+Math.PI*1.6*frac); ctx.stroke();

  // restore alpha
  ctx.globalAlpha = 1;
  

}



  // ---------- Flagships ----------
  function drawFlag(fs, color){
    const rx=fs.x-fs.w/2, ry=fs.y-fs.h/2;
    if(Settings.bloom){ ctx.globalAlpha=.25; ctx.fillStyle=color; ctx.fillRect(rx-10,ry-10,fs.w+20,fs.h+20); ctx.globalAlpha=1; }
    ctx.strokeStyle=color; ctx.lineWidth=3*DPR;
    ctx.beginPath();
    if(fs===Flag.ally){
      ctx.moveTo(rx,ry); ctx.lineTo(rx+fs.w,ry+fs.h*.18); ctx.lineTo(rx+fs.w,ry+fs.h*.82); ctx.lineTo(rx,ry+fs.h); ctx.closePath();
    }else{
      ctx.moveTo(rx+fs.w,ry); ctx.lineTo(rx,ry+fs.h*.18); ctx.lineTo(rx,ry+fs.h*.82); ctx.lineTo(rx+fs.w,ry+fs.h); ctx.closePath();
    }
    ctx.stroke();
    const r = (fs.hp/fs.hpMax);
    ctx.fillStyle='rgba(255,255,255,.06)';
    const bx = fs===Flag.ally ? rx-8 : rx+fs.w+2;
    ctx.fillRect(bx,ry,6,fs.h);
    ctx.fillStyle=color; ctx.fillRect(bx,ry+(1-r)*fs.h,6,fs.h*r);
  }

  // ---------- AI ----------
// ---------- AI (Min‚ÄìMax spawn planner) ----------

// ---------- AI (Foresight Minimax v2) ----------
function pickPersonality(){ Enemy.personality = ['rusher','balanced','harasser'][ Round % 3 ]; }

const TYPES = ['Fighter','Interceptor','Bomber','Frigate','Drone'];

// Enemy gets shorter type cooldowns (so it can ‚Äúswarm‚Äù after saving)
const ENEMY_CD_FACTOR = (Settings.difficulty===2? 0.5 : Settings.difficulty===1? 0.66 : 0.8);

const enemyTypeCD = { Fighter:0, Interceptor:0, Bomber:0, Frigate:0, Drone:0 };

const AI = {
  timer: 0.0,
  thinkCD: 0.0,                  // how often we recompute (seconds)
  lastSig: '',
  inSurge:false, surgeCD:14, surgeT:0,
};

// Quick composition snapshot
function compCounts(){
  const ally   = {Fighter:0,Interceptor:0,Bomber:0,Drone:0,Frigate:0};
  const enemy  = {Fighter:0,Interceptor:0,Bomber:0,Drone:0,Frigate:0};
  for (const s of ships){
    if (s.team===TEAM.ALLY)  ally[s.type]++; else enemy[s.type]++;
  }
  return {ally, enemy};
}

// Costs from BASE
const TYPE_COST = Object.fromEntries(TYPES.map(t => [t, BASE[t].cost]));

// Balanced base weights (Interceptor toned down a bit)
const TYPE_WEIGHT = {
  Fighter:     1.05,
  Interceptor: 1.30, // was 1.55
  Bomber:      1.25,
  Frigate:     1.45,
  Drone:       0.65
};

// Who counters whom (>1 good vs that ally type)
const COUNTER = {
  Fighter:     {Fighter:1.0,  Interceptor:1.0,  Bomber:1.15, Frigate:0.95, Drone:1.1},
  Interceptor: {Fighter:1.05, Interceptor:1.0,  Bomber:1.25, Frigate:0.95, Drone:1.0},
  Bomber:      {Fighter:0.95, Interceptor:0.85, Bomber:1.0,  Frigate:1.10, Drone:1.0},
  Frigate:     {Fighter:1.20, Interceptor:1.10, Bomber:0.95, Frigate:1.0,  Drone:1.1},
  Drone:       {Fighter:0.9,  Interceptor:0.95, Bomber:1.0,  Frigate:0.95, Drone:1.0}
};

// Soft diversity (penalize over-represented types)
function diversityPenalty(counts){
  // Œª * sum(count^1.6)
  const Œª = 0.12;
  let p = 0;
  for (const t of TYPES) p += Math.pow(counts[t]||0, 1.6);
  return Œª * p;
}

// Light synergy: screens + heals help bombers/fragiles
function synergyBonus(counts){
  let b = 0;
  // Fighter screen helps Bombers push
  b += 0.05 * Math.min(counts.Fighter||0, counts.Bomber||0);
  // Drones help everything (cap a bit)
  const d = Math.min(3, counts.Drone||0);
  b += 0.06 * d * ((counts.Fighter||0)+(counts.Interceptor||0)+(counts.Bomber||0)+(counts.Frigate||0)) / 12;
  // Frigate + Drone sustain line
  b += 0.05 * Math.min(counts.Frigate||0, d);
  return b;
}

// Heuristic value of a (ally, enemy) mix. Positive = ENEMY advantage.
function scoreMix(Ally, EnemyMix, ctx){
  // raw power
  let allyRaw=0, enemyRaw=0;
  for (const t of TYPES){ allyRaw  += (Ally[t]||0)  * TYPE_WEIGHT[t];
                          enemyRaw += (EnemyMix[t]||0)* TYPE_WEIGHT[t]; }

  // counters
  let enemyVsAlly=0, allyVsEnemy=0;
  for (const et of TYPES){
    for (const at of TYPES){
      const pairs = Math.min(EnemyMix[et]||0, Ally[at]||0);
      if (pairs>0){
        enemyVsAlly += pairs * (COUNTER[et][at] - 1.0);
        allyVsEnemy += pairs * (COUNTER[at][et] - 1.0);
      }
    }
  }

  // synergy & diversity
  const synE = synergyBonus(EnemyMix) - diversityPenalty(EnemyMix);
  const synA = synergyBonus(Ally)     - diversityPenalty(Ally);

  // energy float (who can escalate soon)
  const econ = 0.06 * ((ctx.eE || 0) - (ctx.eA || 0));

  // boss bias: during boss, value ranged/sustain a bit more
  const bossBias =
    (bossActive ? 0.12*((EnemyMix.Frigate||0)+(EnemyMix.Interceptor||0)) - 0.06*(EnemyMix.Fighter||0)
                : 0);

  return (enemyRaw - allyRaw)*0.9
       + (enemyVsAlly - allyVsEnemy)*0.6
       + (synE - synA)
       + econ
       + bossBias;
}

// State for planning
function sigOfCounts(c){ return TYPES.map(t=>c[t]||0).join(','); }

function snapshotState(){
  const {ally, enemy} = compCounts();
  return {
    A: {...ally},
    E: {...enemy},
    eA: Player.energy,
    eE: Enemy.energy,
    cdA: {...typeCooldown},                      // player‚Äôs real cds
    cdE: {...enemyTypeCD},                       // enemy cds
  };
}

function stepRegen(st, dt){
  st.eA = Math.min(Player.energyMax, st.eA + Player.energyRegen * dt);
  st.eE = Math.min(Enemy.energyMax,  st.eE + Enemy.energyRegen  * dt);
  for (const t of TYPES){ st.cdA[t] = Math.max(0, st.cdA[t]-dt); st.cdE[t] = Math.max(0, st.cdE[t]-dt); }
}

function canSpawnSide(st, type, side){
  const cost = TYPE_COST[type];
  if (side==='E') return st.eE >= cost && st.cdE[type]<=0;
  else            return st.eA >= cost && st.cdA[type]<=0;
}
function doSpawnSide(st, type, side){
  const cost = TYPE_COST[type];
  if (side==='E'){
    st.eE -= cost; st.E[type]=(st.E[type]||0)+1; st.cdE[type] = (typeCDLen[type]||0.6)*ENEMY_CD_FACTOR;
  } else {
    st.eA -= cost; st.A[type]=(st.A[type]||0)+1; st.cdA[type] = (typeCDLen[type]||0.6);
  }
}

// Move generator (includes WAIT)
function genMoves(st, side){
  const moves = ['WAIT'];
  const budget = side==='E' ? st.eE : st.eA;
  const cds    = side==='E' ? st.cdE : st.cdA;
  for (const t of TYPES){
    if (budget >= TYPE_COST[t] && cds[t]<=0) moves.push(t);
  }
  // Order by marginal value (rough)
  if (side==='E'){
    moves.sort((ma,mb)=>{
      const va = (ma==='WAIT') ? 0 : scoreMix(st.A, {...st.E, [ma]:(st.E[ma]||0)+1}, st) - scoreMix(st.A, st.E, st);
      const vb = (mb==='WAIT') ? 0 : scoreMix(st.A, {...st.E, [mb]:(st.E[mb]||0)+1}, st) - scoreMix(st.A, st.E, st);
      return vb - va;
    });
  }
  return moves.slice(0, 5); // beam width
}

// Minimax with tiny horizon and alpha-beta
function minimax(st, depth, horizonTime, turn, alpha, beta){
  // horizonTime ticks down by step; when <=0 or depth==0, evaluate
  if (depth===0 || horizonTime<=0){
    return { val: scoreMix(st.A, st.E, st), first:null };
  }

  const STEP = 0.5; // seconds per ply
  if (turn==='E'){ // maximizing
    let best = { val:-Infinity, first:null };
    const moves = genMoves(st,'E');
    for (const mv of moves){
      const ns = {
        A:{...st.A}, E:{...st.E},
        eA:st.eA, eE:st.eE,
        cdA:{...st.cdA}, cdE:{...st.cdE}
      };
      if (mv!=='WAIT') doSpawnSide(ns, mv, 'E');
      stepRegen(ns, STEP);
      const out = minimax(ns, depth-1, horizonTime-STEP, 'A', alpha, beta);
      const val = out.val;
      if (val > best.val){ best = { val, first: (best.first??mv) || mv }; }
      alpha = Math.max(alpha, val);
      if (beta <= alpha) break;
    }
    return best;
  } else { // player turn (minimizing)
    let best = { val:+Infinity, first:null };
    const moves = genMoves(st,'A');
    for (const mv of moves){
      const ns = {
        A:{...st.A}, E:{...st.E},
        eA:st.eA, eE:st.eE,
        cdA:{...st.cdA}, cdE:{...st.cdE}
      };
      if (mv!=='WAIT') doSpawnSide(ns, mv, 'A');
      stepRegen(ns, STEP);
      const out = minimax(ns, depth-1, horizonTime-STEP, 'E', alpha, beta);
      const val = out.val;
      if (val < best.val){ best = { val, first: (best.first??mv) || mv }; }
      beta = Math.min(beta, val);
      if (beta <= alpha) break;
    }
    return best;
  }
}

// Decide next enemy action with planning & ‚Äúsave for swarm‚Äù behavior
function decideEnemyAction(){
  const st = snapshotState();

  // Recompute plan signature (composition + integer energies) to avoid thrash
  const sig = `${sigOfCounts(st.A)}|${sigOfCounts(st.E)}|${(st.eA|0)}|${(st.eE|0)}|${bossActive?'B':'-'}`;
  const needThink = (AI.lastSig !== sig);
  if (needThink) AI.lastSig = sig;

  // Lookahead depth/horizon tuned for speed
  const DEPTH   = 6;     // plies
  const HORIZON = 3.0;   // seconds

  const res = minimax(st, DEPTH, HORIZON, 'E', -Infinity, +Infinity);
  const pick = res.first; // could be 'WAIT' or a type

  // ‚ÄúSave for swarm‚Äù: if best is WAIT but we‚Äôre close to affording a high-impact unit, keep waiting.
  if (pick==='WAIT'){
    // Heuristic: if Frigate or Bomber would flip the eval by enough, wait.
    const needFrig = TYPE_COST.Frigate;
    const needBomb = TYPE_COST.Bomber;
    const canSoonFrig = (Enemy.energy + Enemy.energyRegen*1.0 >= needFrig && enemyTypeCD.Frigate<=0);
    const canSoonBomb = (Enemy.energy + Enemy.energyRegen*1.0 >= needBomb && enemyTypeCD.Bomber<=0);
    if (canSoonFrig || canSoonBomb) return null; // wait
  }

  // During surge, try to burst up to 2 units (different types to keep diversity)
  if (AI.inSurge && pick && pick!=='WAIT'){
    const spawned = [];
    const trySpawn = (t)=>{
      const need = TYPE_COST[t] * (Enemy.difficultyBias||1.0);
      if (Enemy.energy >= need && enemyTypeCD[t]<=0){
        Enemy.energy -= need;
        spawnShip(t, TEAM.ENEMY);
        enemyTypeCD[t] = (typeCDLen[t]||0.6)*ENEMY_CD_FACTOR;
        spawned.push(t);
      }
    };
    trySpawn(pick);
    // second pick: pick best different type by marginal
    let best2 = null, bestGain = -1e9;
    for (const t of TYPES){
      if (t===pick) continue;
      if (Enemy.energy < TYPE_COST[t] || enemyTypeCD[t]>0) continue;
      const cur = scoreMix(st.A, st.E, st);
      const gain = scoreMix(st.A, {...st.E, [t]:(st.E[t]||0)+1}, st) - cur;
      if (gain>bestGain){ bestGain=gain; best2=t; }
    }
    if (best2) trySpawn(best2);
    return spawned.length ? 'burst' : null;
  }

  // Normal single spawn
  if (pick && pick!=='WAIT'){
    const need = TYPE_COST[pick] * (Enemy.difficultyBias||1.0);
    if (Enemy.energy >= need && enemyTypeCD[pick]<=0){
      Enemy.energy -= need;
      spawnShip(pick, TEAM.ENEMY);
      enemyTypeCD[pick] = (typeCDLen[pick]||0.6)*ENEMY_CD_FACTOR;
      return pick;
    }
  }
  return null; // wait
}

function aiTick(dt){
  // update type CDs
  for (const t of TYPES) enemyTypeCD[t] = Math.max(0, enemyTypeCD[t]-dt);

  // surge schedule (enemy bursts)
  AI.surgeCD -= dt;
  if (!AI.inSurge && AI.surgeCD<=0){
    AI.inSurge = true; AI.surgeT = (Settings.difficulty===2? 3.6 : 3.0);
    AI.surgeCD = (Settings.difficulty===2? 16  : 20);
    toast('‚ö† Enemy surge!');
  }
  if (AI.inSurge){ AI.surgeT -= dt; if (AI.surgeT<=0) AI.inSurge=false; }

  // cadence: enemy thinks faster than before (esp. on Hard)
  const bossFactor = bossActive ? 1.1 : 1.0;
  const decLo = (Settings.difficulty===2? 0.28 : Settings.difficulty===1? 0.40 : 0.55);
  const decHi = (Settings.difficulty===2? 0.45 : Settings.difficulty===1? 0.60 : 0.80);

  AI.timer -= dt;
  if (AI.timer<=0){
    AI.timer = rand(decLo,decHi) * bossFactor * (AI.inSurge? 0.7 : 1.0);

    // population cap safety
    const enemyCount = ships.reduce((n,s)=> n + (s.team===TEAM.ENEMY), 0);
    if (enemyCount > 32) return;

    // occasionally force a rethink even if signature didn‚Äôt change
    AI.thinkCD -= dt;
    if (AI.thinkCD<=0) { AI.lastSig = ''; AI.thinkCD = 0.8; }

    decideEnemyAction();
  }
}

  // ---------- UI: deploy bar ----------
  const deployBar = $('deployBar');
  function makeDeployBar(){
    deployBar.innerHTML = '';
    ORDER.forEach((t,i)=>{
      const c = document.createElement('div'); c.className='card';
      c.innerHTML = `<button class="btn" data-type="${t}">${i+1}. ${t}</button>
        <span class="badge">Cost ${BASE[t].cost}</span>
        <div class="grow"></div>
        <div class="cooldown" style="width:80px"><i id="cd_${t}"></i></div>`;
      deployBar.appendChild(c);
    });
    deployBar.addEventListener('click', e=>{
      const b = e.target.closest('button[data-type]'); if(!b) return;
      Selected.type = b.dataset.type; tryDeploy(Selected.type, TEAM.ALLY) || beep(220,.05,.05,'triangle');
    });
  }
  function updateDeployCD(t){
    const el = $('cd_'+t); if(!el) return;
    const len = typeCDLen[t], left = clamp(typeCooldown[t]/len,0,1);
    el.style.width = ((1-left)*100)+'%';
  }

  // ---------- Menus ----------
  function show(id, on=true){ $(id).classList.toggle('show', on); }
  function start(){
    show('title',false); playing=true; paused=false; gameOver=false;
    Round=1; roundTime=0; nextBossIn= (Round%5===0? 2 : 0); bossActive=false; boss=null;
    resetBattle();
  }
  function resetBattle(){
    ships.length=0; shots.length=0; parts.length=0; heals.length=0; boss=null; bossActive=false; bossCleared=false;
    Player.hpMax = Math.floor(1100*(1+(Player.upgrades.hp||0)*0.12)); Player.hp = Player.hpMax;
    Enemy.hpMax  = Player.hpMax; Enemy.hp = Enemy.hpMax;
    Flag.ally.hpMax=Player.hpMax; Flag.ally.hp=Player.hp;
    Flag.enemy.hpMax=Enemy.hpMax; Flag.enemy.hp=Enemy.hp;
    Player.energy=Player.energyMax; Enemy.energy=Enemy.energyMax;
    AI.timer=1.0; Enemy.specialUsed=false; pickPersonality();
    setHPHUD(); setEnergyHUD(); setRoundHUD(); setMoneyHUD(); setBossHUD();
  }

  // ---------- Buttons & Keys ----------
  $('startBtn').addEventListener('click', ()=>{ initAudio(); start(); });
  $('openShopFromTitle').addEventListener('click', ()=>{
    buildShop();
    show('shop',true);
    const b = $('shopNextBtn');
    if (b) b.textContent = (LastOutcome === 'loss') ? '‚Ü∫ Retry' : '‚ñ∂ Next Battle';
  });

  $('shopNextBtn').addEventListener('click', ()=>{
  // Decide: retry same round on loss, advance on win/neutral
  const retry = (LastOutcome === 'loss');

  show('shop', false);
  show('gameover', false);
  show('title', false);  // stay in-game

  if (retry) {
    // Retry current round
    roundTime = 0;
    nextBossIn = (Round % 5 === 0 ? 3 : 0);
    resetBattle();
    playing = true;
    toast('‚Ü∫ Retry!');
  } else {
    // Next round
    Round++;
    roundTime = 0;
    nextBossIn = (Round % 5 === 0 ? 3 : 0);
    resetBattle();
    playing = true;
    toast(`‚ñ∂ Round ${Round}`);
  }
});

  $('toMenuFromShop').addEventListener('click', ()=>{
    // leave shop and go to title safely
    show('shop', false);
    show('title', true);
    // ensure we‚Äôre not in an in-between state
    playing = false;
    paused = false;
    gameOver = false;
    // (optional) reset the battle state so starting again is clean
    resetBattle();
  });

  // Key
  addEventListener('keydown', e=>{
    if(e.code==='KeyP'){ setPaused( !$('pause').classList.contains('show') ); }
    if(e.code==='Space'){ tryDeploy(Selected.type, TEAM.ALLY); }
    if(e.code==='Digit1') { Selected.type='Fighter'; tryDeploy(Selected.type, TEAM.ALLY); };
    if(e.code==='Digit2') { Selected.type='Interceptor'; tryDeploy(Selected.type, TEAM.ALLY);}
    if(e.code==='Digit3') { Selected.type='Bomber'; tryDeploy(Selected.type, TEAM.ALLY);}
    if(e.code==='Digit4') { Selected.type='Drone'; tryDeploy(Selected.type, TEAM.ALLY);}
    if(e.code==='Digit5') { Selected.type='Frigate'; tryDeploy(Selected.type, TEAM.ALLY);}
  });

  $('resumeBtn').addEventListener('click', ()=> show('pause',false));
  $('restartBtn').addEventListener('click', ()=>{ show('pause',false); resetBattle(); playing=true; });
  $('toTitleBtn').addEventListener('click', ()=>{ show('pause',false); show('title',true); playing=false; });
  $('spendBtn').addEventListener('click', ()=>{
    show('gameover',false);
    buildShop();
    show('shop',true);
    const b = $('shopNextBtn');
    if (b) b.textContent = (LastOutcome === 'loss') ? '‚Ü∫ Retry' : '‚ñ∂ Next Battle';
  });

  $('nextBtn').addEventListener('click', ()=>{
    show('gameover',false);
    const mode = $('nextBtn').dataset.mode || 'next';
    if(mode==='retry'){
      roundTime=0; nextBossIn = (Round%5===0? 3 : 0);
      resetBattle(); playing=true;
    }else{
      Round++; roundTime=0; nextBossIn = (Round%5===0? 3 : 0);
      resetBattle(); playing=true;
    }
  });
  $('quitBtn').addEventListener('click', ()=>{ show('gameover',false); show('title',true); playing=false; });

  $('speedBtn').addEventListener('click', ()=>{
    const idx = Speed.steps.indexOf(Speed.mult);
    Speed.mult = Speed.steps[(idx+1)%Speed.steps.length];
    setSpeedHUD(); toast(`Speed ${Speed.mult}√ó`);
  });
  $('helpBtn').addEventListener('click', ()=> toast('1‚Äì5 pick ship, Space deploy, P pause. Spend credits in Shop. Use ‚ÄúMax Deploy‚Äù to burst.'));
  $('shotBtn').addEventListener('click', ()=>{
    try{ const a=document.createElement('a'); a.download=`void-wars-${Date.now()}.png`; a.href=cv.toDataURL('image/png'); a.click(); }catch{}
  });
  $('maxBtn').addEventListener('click', (e)=>{
    Modes.maxDeploy = !Modes.maxDeploy;
    e.currentTarget.textContent = `‚®â Max Deploy: ${Modes.maxDeploy ? 'On' : 'Off'}`;
    toast(Modes.maxDeploy ? 'Max deploy enabled' : 'Max deploy disabled');
  });

  addEventListener('keydown', e=>{
    if(e.code==='KeyP'){ show('pause', !$('pause').classList.contains('show')); }
    if(e.code==='Space'){ tryDeploy(Selected.type, TEAM.ALLY); }
    if(e.code==='Digit1') Selected.type='Fighter';
    if(e.code==='Digit2') Selected.type='Interceptor';
    if(e.code==='Digit3') Selected.type='Bomber';
    if(e.code==='Digit4') Selected.type='Drone';
    if(e.code==='Digit5') Selected.type='Frigate';
  });

  // Options
  document.querySelectorAll('[data-diff]').forEach(b=> b.addEventListener('click', ()=>{
    document.querySelectorAll('[data-diff]').forEach(x=>x.classList.remove('primary','danger'));
    const v=Number(b.dataset.diff); Settings.difficulty=v; b.classList.add(v===2?'danger':'primary');
    Enemy.energyRegen = (v===2?1.3:(v===1?1.15:1.0)) * 3;

    Enemy.difficultyBias = (v===2 ? 0.90 : v===1 ? 1.00 : 1.10);
    Player.hpMax = v===0?1200:(v===2?1050:1100); Player.hp=Player.hpMax;
    setHPHUD(); toast(`Difficulty: ${['Easy','Normal','Hard'][v]}`);
  }));
  $('optParticles').addEventListener('change', e=>Settings.particles=e.target.checked);
  $('optBloom').addEventListener('change', e=>Settings.bloom=e.target.checked);
  $('optShake').addEventListener('change', e=>Settings.shake=e.target.checked);
  $('optSfx').addEventListener('change', e=>Settings.sfx=e.target.checked);
  $('optVol').addEventListener('input', e=> masterVol=Number(e.target.value));

  // ---------- Shop UI ----------
  function buildShop(){
    const list=$('shopList'); list.innerHTML='';
    UPG.forEach(u=>{
      const lvl = Player.upgrades[u.key]||0;
      const cost = upgCost(u.key);
      const item = document.createElement('div');
      item.className='shop-item';
      item.innerHTML = `<strong>${u.name}</strong><span class="badge">Lv ${lvl}</span><span class="badge">${u.desc}</span>
        <span class="price badge">Cost ${cost}</span>
        <button class="btn small" data-upg="${u.key}">Buy</button>`;
      list.appendChild(item);
    });
    list.addEventListener('click', onBuyOnce, {once:true});
    setMoneyHUD();
  }
  function onBuyOnce(e){
    const btn = e.target.closest('button[data-upg]'); if(!btn) {
      $('shopList').addEventListener('click', onBuyOnce, {once:true}); return;
    }
    const key = btn.dataset.upg;
    const cost = upgCost(key);
    if(Player.credits>=cost){
      Player.credits -= cost; Player.upgrades[key]=(Player.upgrades[key]||0)+1;
      applyStats(); setMoneyHUD(); toast(`Upgraded ${key} ‚Äî next ${upgCost(key)}c`);
      buildShop();
    }else toast('Not enough credits');
    $('shopList').addEventListener('click', onBuyOnce, {once:true});
  }

  // ---------- Drawing ----------
  function drawShip(s){
    const stroke=TEAM_COLOR(s.team), accent=TYPE_ACCENT[s.type]||stroke;
    if(Settings.bloom){ ctx.globalAlpha=.22; ctx.fillStyle=(s.team===TEAM.ALLY?'rgba(0,245,255,.25)':'rgba(255,77,122,.25)'); ctx.beginPath(); ctx.arc(s.x,s.y,16,0,TAU); ctx.fill(); ctx.globalAlpha=1; }
    ctx.strokeStyle=stroke; ctx.lineWidth=2*DPR;

    const ang = Math.atan2(s.vy,s.vx)||0;
    ctx.save(); ctx.translate(s.x,s.y); ctx.rotate(ang);

    ctx.beginPath();
    if(s.type==='Fighter'){
      ctx.moveTo(12,0); ctx.lineTo(-10,-8); ctx.lineTo(-10,8); ctx.closePath();
    }else if(s.type==='Interceptor'){
      ctx.moveTo(13,0); ctx.lineTo(0,-10); ctx.lineTo(-13,0); ctx.lineTo(0,10); ctx.closePath();
    }else if(s.type==='Bomber'){
      ctx.moveTo(14,0); ctx.lineTo(-12,-9); ctx.lineTo(-12,9); ctx.closePath();
    }else if(s.type==='Drone'){
      ctx.arc(0,0,9,0,TAU);
    }else if(s.type==='Frigate'){
      for(let i=0;i<6;i++){ const a=Math.PI/6 + i*TAU/6; const px=Math.cos(a)*12, py=Math.sin(a)*12; if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py); }
      ctx.closePath();
    }
    ctx.stroke();
    ctx.strokeStyle=accent; ctx.lineWidth=1.5*DPR;
    if(s.type==='Interceptor'){ ctx.beginPath(); ctx.moveTo(-12,-6); ctx.lineTo(-18,-2); ctx.moveTo(-12,6); ctx.lineTo(-18,2); ctx.stroke(); }
    if(s.type==='Bomber'){ ctx.beginPath(); ctx.moveTo(-8,-6); ctx.lineTo(-8,6); ctx.stroke(); }
    if(s.type==='Frigate'){ ctx.beginPath(); ctx.moveTo(8,-6); ctx.lineTo(16,-10); ctx.moveTo(8,6); ctx.lineTo(16,10); ctx.stroke(); }
    ctx.restore();

    const w=24,h=4;
    ctx.fillStyle='rgba(255,255,255,.08)'; ctx.fillRect(s.x-w/2, s.y-18, w, h);
    ctx.fillStyle=stroke; ctx.fillRect(s.x-w/2, s.y-18, (s.hp/s.hpMax)*w, h);
  }

  function drawHeals(){
    for(const h of heals){
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle='#aef'; ctx.lineWidth=2*DPR;
      ctx.beginPath(); ctx.moveTo(h.x1,h.y1); ctx.lineTo(h.x2,h.y2); ctx.stroke();
      ctx.globalCompositeOperation='source-over';
    }
  }

  function drawShots(){
    ctx.globalCompositeOperation='lighter';
    for(const b of shots){
      ctx.strokeStyle=TEAM_COLOR(b.team); ctx.lineWidth=2.4*DPR;
      ctx.beginPath(); ctx.moveTo(b.x-b.vx*.8, b.y-b.vy*.8); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
    ctx.globalCompositeOperation='source-over';
  }

  // ---------- Round flow ----------
  function victory(v){
    playing=false; gameOver=true;
    const dealt = Math.max(0, Enemy.hpMax-Enemy.hp);
    const taken = Math.max(0, Player.hpMax-Player.hp);
    const reward = (v? (200+Round*35) : (70+Round*16)) + (bossActive? 120:0);
    Player.credits += reward; setMoneyHUD();
    $('resultTitle').textContent = v? 'Victory' : 'Defeat';
    $('statsText').textContent = `Round ${Round} ‚Äî Damage Dealt: ${dealt} ¬∑ Taken: ${taken} ¬∑ Reward: +${reward}c`;

     // NEW: remember last result
    LastOutcome = v ? 'win' : 'loss';

    const nextBtn = $('nextBtn');
    if(v){
      nextBtn.textContent = '‚ñ∂ Next Round';
      nextBtn.dataset.mode = 'next';
    }else{
      nextBtn.textContent = '‚Ü∫ Retry';
      nextBtn.dataset.mode = 'retry';
    }
    show('gameover',true);
  }

  // ---------- Main loop ----------
  let last=performance.now(), acc=0, dt=1/60;
  makeDeployBar(); setSpeedHUD();

  function frame(){
  const now = performance.now(), raw = (now - last)/1000; last = now;
  acc += raw * Speed.mult;

  if (audioCtx) audioCtx.suspend && (Speed.mult < 1.01 && !paused ? audioCtx.suspend() : audioCtx.resume());

  while (acc >= dt){
    acc -= dt;

    if (playing && !paused){
      roundTime += dt; setTimeHUD();

      // energy ticks
      Player.energy = Math.min(Player.energyMax, Player.energy + Player.energyRegen*dt); setEnergyHUD();
      Enemy.energy  = Math.min(Enemy.energyMax,  Enemy.energy  + Enemy.energyRegen*dt);

      // boss countdown/spawn
      if (Round % 5 === 0 && !bossActive && !bossCleared){
        nextBossIn = Math.max(0, nextBossIn - dt); setBossHUD();
        if (nextBossIn <= 0) spawnBoss();
      }

      updateShips(dt);
      collisions(dt);
      aiTick(dt);

      // --- Boss update & HP mirroring ---
      let bossDiedThisTick = false;

      if (bossActive){
        updateBoss(dt);

        if (boss && boss.hp <= 0){
          // cache for optional FX
          const cx = boss.x, cy = boss.y;

          boss = null;
          bossActive = false;
          bossCleared = true;

          // visuals/HUD cleanup first (so they actually show)
          toast('Boss defeated!');
          Enemy.hp = Enemy.hpMax;         // restore enemy flagship bars
          setBossHUD();

          // optional death FX (kept lightweight)
          for (let k=0; k<60; k++) spark(cx, cy, '#ffd36b', 1.2, 0.8);
          addShake(10);

          // mark and resolve victory this tick (no early return!)
          bossDiedThisTick = true;
          victory(true);
        } else if (boss){
          // mirror boss HP into enemy flagship HUD while boss lives
          Enemy.hp    = boss.hp;
          Enemy.hpMax = boss.hpMax;
          setBossHUD();
        }
      }

      // Mirror pools to flags (no overwrite thanks to applyDamage redirect)
      Flag.ally.hp    = Player.hp;  Flag.ally.hpMax  = Player.hpMax;
      Flag.enemy.hp   = Enemy.hp;   Flag.enemy.hpMax = Enemy.hpMax;

      // Round end checks ‚Äî skip if we already triggered victory on boss death this tick
      if (!bossDiedThisTick){
        if (Enemy.hp <= 0 && (!boss || boss.hp <= 0)) victory(true);
        if (Player.hp <= 0) victory(false);
      }
    }

    partsUpdate(dt);
  }

  // ----- RENDER -----
  ctx.clearRect(0,0,cv.width,cv.height);
  drawBackground(raw);
  applyCamera();

  ctx.strokeStyle='rgba(255,255,255,.06)';
  ctx.beginPath(); ctx.moveTo(cv.width/2,0); ctx.lineTo(cv.width/2,cv.height); ctx.stroke();

  drawFlag(Flag.ally, '#00faff');
  if (!bossActive) drawFlag(Flag.enemy, '#ff4d7a');

  if (bossActive) drawBoss();

  for (const s of ships) drawShip(s);
  drawShots();
  drawHeals();
  partsDraw();

  resetCamera();
  setHPHUD();

  // keep the loop alive every frame
  requestAnimationFrame(frame);
}

  
  frame();

})();
</script>
</body>
</html>

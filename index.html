<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>VOID WARS ‚Äî Duel of Flagships</title>
<style>
  :root{
    --fg:#eaffff; --muted:#9bb0bd; --line:rgba(255,255,255,.08);
    --panel:rgba(10,12,20,.72); --panel-strong:rgba(10,12,20,.92);
    --accent:#00faff; --danger:#ff4d7a; --good:#50ffa8; --gold:#ffd36b;
    --enemy:#ff4d7a; --ally:#51d9ff;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:radial-gradient(1400px 900px at 50% 30%,#0a0f1c 0%,#05060b 45%,#030409 100%);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;overflow:hidden}
  canvas{display:block;width:100vw;height:100vh;image-rendering:pixelated}

  /* HUD (auto-fit) */
  .hud{position:fixed;inset:8px 8px auto 8px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;pointer-events:none}
  .chip{pointer-events:none;background:var(--panel);border:1px solid var(--line);padding:6px 10px;border-radius:10px;display:flex;align-items:center;gap:8px;font-size:12px}
  .chip .bar{position:relative; width:140px;height:8px;border-radius:8px;background:rgba(255,255,255,.06);border:1px solid var(--line);overflow:hidden}
  .chip .bar>i{position:absolute;inset:0;background:linear-gradient(90deg,var(--good),#9cffea,var(--accent))}
  .badge{background:rgba(255,255,255,.06);border:1px solid var(--line);padding:2px 6px;border-radius:8px;color:var(--muted);font-size:11px}
  .money{color:var(--gold)}
  .kbd{font-family:ui-monospace, Menlo, Consolas, monospace;background:rgba(255,255,255,.06);border:1px solid var(--line);padding:1px 4px;border-radius:6px}

  /* Bottom deploy bar */
  .deploy{position:fixed;left:8px;right:8px;bottom:8px;display:flex;gap:8px}
  .card{flex:1;min-width:0;background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:6px 8px;display:flex;align-items:center;gap:8px}
  .btn{appearance:none;border:1px solid var(--line);background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));color:var(--fg);padding:8px 10px;border-radius:10px;cursor:pointer;transition:.15s transform,.2s box-shadow,.2s border-color}
  .btn:hover{transform:translateY(-1px);box-shadow:0 10px 18px rgba(0,0,0,.25)}
  .btn.primary{border-color:rgba(0,250,255,.35)}
  .btn.danger{border-color:rgba(255,59,106,.35)}
  .row{display:flex;gap:8px;align-items:center}
  .grow{flex:1}
  .cooldown{height:6px;background:rgba(255,255,255,.06);border:1px solid var(--line);border-radius:8px;overflow:hidden}
  .cooldown>i{display:block;height:100%;background:linear-gradient(90deg,#79e5ff,#9a5cff);width:0%}

  /* Modals */
  .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center}
  .overlay.show{display:flex}
  .modal{pointer-events:auto;width:min(980px,96vw);max-height:86vh;overflow:auto;background:var(--panel-strong);border:1px solid var(--line);border-radius:16px;backdrop-filter:blur(12px);padding:14px;box-shadow:0 20px 60px rgba(0,0,0,.45)}
  .title{font-weight:800;letter-spacing:2px;text-transform:uppercase;color:var(--accent)}
  .list{display:flex;flex-direction:column;gap:8px}
  .shop-grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px;max-height:58vh;overflow:auto;padding-right:4px}
  .shop-item{display:flex;gap:10px;align-items:center;background:rgba(255,255,255,.04);border:1px solid var(--line);border-radius:12px;padding:8px}
  .shop-item .price{margin-left:auto}

  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:22px;background:var(--panel-strong);border:1px solid var(--line);padding:8px 12px;border-radius:10px;opacity:0;pointer-events:none}
  .toast.show{animation:toast 2.2s ease}@keyframes toast{0%{opacity:0;transform:translate(-50%,8px)}10%{opacity:1;transform:translate(-50%,0)}90%{opacity:1}100%{opacity:0}}

  /* Small helpers */
  .corner{position:fixed;bottom:8px;right:8px;display:flex;gap:8px}
</style>
</head>
<body>
<canvas id="cv"></canvas>

<!-- HUD -->
<div class="hud" id="hud">
  <div class="chip"><strong>VOID WARS</strong> <span id="speedChip" class="badge">1√ó</span></div>
  <div class="chip">Round <strong id="roundVal">1</strong> <span id="timeVal" class="badge">0:00</span></div>
  <div class="chip">Boss <span id="bossBadge" class="badge">‚Äî</span></div>
  <div class="chip">Energy
    <div class="bar"><i id="energyFill" style="width:0%"></i></div>
    <span id="energyNum" class="badge">0/10</span>
  </div>
  <div class="chip">HP
    <div class="bar"><i id="hpFill" style="width:100%"></i></div>
    <span id="hpNum" class="badge">100%</span>
  </div>
  <div class="chip">Enemy
    <div class="bar"><i id="ehpFill" style="width:100%"></i></div>
    <span id="ehpNum" class="badge">100%</span>
  </div>
  <div class="chip money">¬¢ <strong id="moneyVal">0</strong></div>
  <div class="chip"><span class="badge">1‚Äì5 or Click ‚Ä¢ Space deploy ‚Ä¢ P pause</span></div>
</div>

<!-- Bottom deploy bar -->
<div class="deploy" id="deployBar">
  <!-- filled by script -->
</div>

<!-- Title -->
<div id="title" class="overlay show">
  <div class="modal">
    <div class="row" style="justify-content:space-between;margin-bottom:8px">
      <div class="title">VOID WARS</div>
      <div class="row">
        <button id="openShopFromTitle" class="btn">‚õ≠ Upgrades</button>
        <button id="startBtn" class="btn primary">‚ñ∂ Start</button>
      </div>
    </div>
    <div class="list" style="gap:6px">
      <div class="row">
        <button class="btn small" data-diff="0">Easy</button>
        <button class="btn small primary" data-diff="1">Normal</button>
        <button class="btn small danger" data-diff="2">Hard</button>
      </div>
      <div class="row" style="gap:12px;align-items:center">
        <label class="row" style="gap:6px"><input id="optParticles" type="checkbox" checked/> Particles</label>
        <label class="row" style="gap:6px"><input id="optBloom" type="checkbox" checked/> Bloom</label>
        <label class="row" style="gap:6px"><input id="optShake" type="checkbox" checked/> Screen Shake</label>
        <label class="row" style="gap:6px"><input id="optSfx" type="checkbox" checked/> SFX</label>
        <span class="row" style="gap:6px">Volume <input id="optVol" type="range" min="0" max="1" step="0.01" value="0.6" style="width:180px"/></span>
      </div>
      <div class="badge">Tip: Every 5th round spawns a boss‚Äîdon‚Äôt let it reach your flagship.</div>
    </div>
  </div>
</div>

<!-- Shop -->
<div id="shop" class="overlay">
  <div class="modal">
    <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:6px">
      <div class="title">Upgrades (credits: <span id="shopCredits" class="money">0</span>)</div>
      <div class="row">
        <button id="toMenuFromShop" class="btn danger">‚éã Go to Menu</button>

      </div>
    </div>
    <div class="shop-grid" id="shopList"></div>
    <div class="badge" style="margin-top:8px">Prices increase: base √ó 1.25^level. Effects apply immediately.</div>
  </div>
</div>

<!-- Pause -->
<div id="pause" class="overlay">
  <div class="modal">
    <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:6px">
      <div class="title">Paused</div>
      <button id="resumeBtn" class="btn primary">Resume</button>
    </div>
    <div class="row">
      <button id="restartBtn" class="btn">‚Ü∫ Restart Round</button>
      <button id="toTitleBtn" class="btn danger">‚éã Quit to Title</button>
    </div>
  </div>
</div>

<!-- Game Over -->
<div id="gameover" class="overlay">
  <div class="modal">
    <div class="title" id="resultTitle">Battle Complete</div>
    <div class="list" style="margin:8px 0">
      <div id="statsText" class="badge">Stats‚Ä¶</div>
    </div>
    <div class="row">
      <button id="spendBtn" class="btn primary">‚õ≠ Spend Credits</button>
      <button id="nextBtn" class="btn">‚ñ∂ Next Round</button>
      <button id="quitBtn" class="btn danger">‚éã Quit to Title</button>
    </div>
  </div>
</div>

<div class="corner">
  <button id="speedBtn" class="btn small">‚è© Speed</button>
  <button id="helpBtn" class="btn small">‚ùî Help</button>
  <button id="shotBtn" class="btn small">üì∏</button>
  <button id="maxBtn" class="btn small">‚®â Max Deploy: Off</button>
</div>

<div id="toast" class="toast"></div>

<script>
(() => {
  "use strict";

  // ---------- Helpers ----------
  const clamp=(v,a,b)=>v<a?a:(v>b?b:v);
  const lerp=(a,b,t)=>a+(b-a)*t;
  const rand=(a,b)=>Math.random()*(b-a)+a;
  const randi=(a,b)=>Math.floor(rand(a,b));
  const TAU=Math.PI*2;

  // ---------- Canvas ----------
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  function resize(){ cv.width=Math.floor(innerWidth*DPR); cv.height=Math.floor(innerHeight*DPR); }
  addEventListener('resize', resize); resize();

  // ---------- Audio (light) ----------
  let masterVol=0.6, audioCtx=null;
  function initAudio(){ if(audioCtx) return; try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch{} }
  function beep(freq=440,dur=.06,gain=.06,type='square'){
    if(!audioCtx || !Settings.sfx) return;
    const t=audioCtx.currentTime, o=audioCtx.createOscillator(), g=audioCtx.createGain();
    o.type=type; o.frequency.value=freq; g.gain.value=gain*masterVol;
    o.connect(g).connect(audioCtx.destination); o.start(t); o.stop(t+dur);
  }

  // ---------- Settings & State ----------
  const Settings = { particles:true, bloom:true, shake:true, sfx:true, difficulty:1 };
  const Speed = { mult:1, steps:[1,1.5,2] };
  const Player = {
    hpMax:1100, hp:1100, energy:0, energyMax:10, energyRegen:2.0, credits:0, // faster default regen
    upgrades:{
      dmg:0, hp:0, erg:0, cap:0, spd:0, armor:0, ram:0, projspd:0, range:0, squad:0, droneR:0, droneT:0, pd:0, aura:0, bossB:0, salvage:0
    }
  };
  const Enemy = {
    hpMax:1100, hp:1100, energy:0, energyMax:10, energyRegen:1.15,
    difficultyBias:1.0,
    specialUsed:false, personality:'balanced'
  };
  let Round=1, roundTime=0, nextBossIn=0, bossActive=false;
  let paused=false, playing=false, gameOver=false;

  // ---------- HUD ----------
  const $ = id=>document.getElementById(id);
  function toast(msg){ const t=$('toast'); t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),2000); }
  function setEnergyHUD(){ const f=Player.energy/Player.energyMax; $('energyFill').style.width=(f*100).toFixed(0)+'%'; $('energyNum').textContent=`${Math.floor(Player.energy)}/${Player.energyMax}`; }
  function setHPHUD(){ const r=Player.hp/Player.hpMax, rr=Enemy.hp/Enemy.hpMax; $('hpFill').style.width=(r*100).toFixed(0)+'%'; $('hpNum').textContent=`${Math.max(0,Math.floor(r*100))}%`; $('ehpFill').style.width=(rr*100).toFixed(0)+'%'; $('ehpNum').textContent=`${Math.max(0,Math.floor(rr*100))}%`; }
  function setMoneyHUD(){ $('moneyVal').textContent=Player.credits; $('shopCredits').textContent=Player.credits; }
  function setRoundHUD(){ $('roundVal').textContent=Round; }
  function setTimeHUD(){ const m=Math.floor(roundTime/60), s=Math.floor(roundTime%60).toString().padStart(2,'0'); $('timeVal').textContent=`${m}:${s}`; }
  function setBossHUD(){ $('bossBadge').textContent = bossActive? 'ACTIVE' : (nextBossIn>0? `${Math.ceil(nextBossIn)}s` : '‚Äî'); }
  function setSpeedHUD(){ $('speedChip').textContent = Speed.mult.toFixed(2).replace(/\.00$/,'')+'√ó'; }

  // ---------- Background (stars) ----------
  const starsFar=[], starsNear=[];
  function seedStars(){
    starsFar.length=0; starsNear.length=0;
    const nFar=Math.floor((cv.width*cv.height)/(9000*DPR)), nNear=Math.floor((cv.width*cv.height)/(16000*DPR));
    for(let i=0;i<nFar;i++) starsFar.push({x:Math.random()*cv.width,y:Math.random()*cv.height,r:rand(.4,1),s:rand(.02,.05)});
    for(let i=0;i<nNear;i++) starsNear.push({x:Math.random()*cv.width,y:Math.random()*cv.height,r:rand(.7,1.8),s:rand(.05,.12)});
  }
  seedStars(); addEventListener('resize', seedStars);
  function drawBackground(dt){
    const g=ctx.createRadialGradient(cv.width*.5, cv.height*.35, 80, cv.width*.5, cv.height*.5, Math.max(cv.width,cv.height)*.9);
    g.addColorStop(0,"rgba(0,200,255,0.08)"); g.addColorStop(.45,"rgba(120,50,255,0.06)"); g.addColorStop(1,"rgba(0,0,0,0)");
    ctx.fillStyle=g; ctx.fillRect(0,0,cv.width,cv.height);
    ctx.globalCompositeOperation='lighter';
    ctx.fillStyle='#fff';
    for(const s of starsFar){ s.x+=s.s*dt*30; if(s.x>cv.width) s.x=0; ctx.globalAlpha=.35; ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,TAU); ctx.fill(); }
    for(const s of starsNear){ s.x+=s.s*dt*60; if(s.x>cv.width) s.x=0; ctx.globalAlpha=.8; ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,TAU); ctx.fill(); }
    ctx.globalAlpha=1; ctx.globalCompositeOperation='source-over';
  }

  // ---------- Particles ----------
  const parts=[];
  function spark(x,y,c="#aef",n=6,spd=1){ if(!Settings.particles) return;
    for(let i=0;i<n;i++) parts.push({x,y,vx:rand(-1,1)*spd,vy:rand(-1,1)*spd,t:0,life:rand(.3,.8),c});
  }
  function ringBlast(x,y,c="#fff",r=6){ if(!Settings.particles) return; parts.push({x,y,ring:1,r0:r,rv:90,t:0,life:.35,c});}
  function partsUpdate(dt){
    for(let i=parts.length-1;i>=0;i--){
      const p=parts[i]; p.t+=dt;
      if(p.ring){ p.r0+=p.rv*dt; if(p.t>p.life) parts.splice(i,1); continue; }
      p.x+=p.vx*dt*60; p.y+=p.vy*dt*60; p.vy+=.02*dt*60; if(p.t>p.life) parts.splice(i,1);
    }
  }
  function partsDraw(){
    if(!Settings.particles) return;
    ctx.globalCompositeOperation='lighter';
    for(const p of parts){
      if(p.ring){ ctx.globalAlpha=1-(p.t/p.life); ctx.strokeStyle=p.c; ctx.lineWidth=2*DPR; ctx.beginPath(); ctx.arc(p.x,p.y,p.r0,0,TAU); ctx.stroke(); continue; }
      const a=1-(p.t/p.life); ctx.globalAlpha=a; ctx.fillStyle=p.c; ctx.fillRect(p.x-1,p.y-1,2,2);
    }
    ctx.globalAlpha=1; ctx.globalCompositeOperation='source-over';
  }

  // ---------- Camera / Shake ----------
  const Cam={shake:0};
  function addShake(s=6){ if(Settings.shake) Cam.shake=Math.min(12,Cam.shake+s); }
  function applyCamera(){ let sx=0,sy=0; if(Cam.shake>0){ sx=rand(-Cam.shake,Cam.shake); sy=rand(-Cam.shake,Cam.shake); Cam.shake*=.9; if(Cam.shake<.2) Cam.shake=0; } ctx.setTransform(1,0,0,1,sx,sy); }
  function resetCamera(){ ctx.setTransform(1,0,0,1,0,0); }

  // ---------- Entities ----------
  const TEAM={ALLY:1, ENEMY:2};
  const TEAM_COLOR=t=>t===TEAM.ALLY?'#51d9ff':'#ff4d7a';
  const TYPE_ACCENT={ Fighter:"#70d7ff", Interceptor:"#6a8bff", Bomber:"#8be0ff", Drone:"#50ffa8", Frigate:"#ffd36b" };

  const BASE = {
    Fighter:{hp:56, dmg:6, spd:120.9, turn:3.2, cost:2,  range:0, mass:2.0,  r:11},
    Interceptor:{hp:62, dmg:8, spd:200.1, turn:2.6, cost:3,  range:140, mass:1.2, r:12},
    Bomber:{hp:140,dmg:30,spd:100.3, turn:1.8, cost:4,  range:80,  mass:2.2, r:14, boom:90, boomD:40},
    Drone:{hp:70, dmg:5, spd:100.6, turn:2.2, cost:3,  range:110, mass:1.1, r:12, heal:12},
    Frigate:{hp:90, dmg:16,spd:100.6, turn:2.0, cost:5,  range:220, mass:1.6, r:13, proj:5},
  };
  const ORDER = ['Fighter','Interceptor','Bomber','Drone','Frigate'];
  // --- Collision tuning ---
  const MIN_REL_HIT = 0.6;         // ignore super-soft bumps
  const MAX_COLL_DMG = 14;         // hard cap per collision tick
  const COLLISION_SCALE = {        // type-specific incoming-collision scaling
    Fighter: 0.25,
    Interceptor: 0.45,
    Bomber: 0.70,
    Drone: 0.40,
    Frigate: 0.65
  };

  const FIGHTER_MELEE_DPS_MULT = 0.5;   // ~ (1.2 hit) / (0.22s) ‚âà 5.45√ó dmg/sec
  const FIGHTER_MELEE_PAD = 2;
  
  
  const ships=[], shots=[], heals=[];
  let boss=null;

  // Flagships (collidable)
  const Flag = {
    ally:{x:140, y:cv.height*0.5, w:28, h:240, team:TEAM.ALLY},
    enemy:{x:cv.width-140, y:cv.height*0.5, w:28, h:240, team:TEAM.ENEMY}
  };
  addEventListener('resize', ()=>{
    Flag.ally.y = cv.height*0.5; Flag.enemy.x = cv.width-140; Flag.enemy.y = cv.height*0.5;
  });

  // ---------- Shop (progressive prices) ----------
  const UPG = [
    {key:'dmg',    name:'Weapon Damage',  desc:'+10% ship damage', base:120, per:0.10},
    {key:'hp',     name:'Hull Plating',  desc:'+12% max HP',      base:120, per:0.12},
    {key:'erg',    name:'Reactor Regen', desc:'+15% energy regen',base:140, per:0.15},
    {key:'cap',    name:'Energy Cap',    desc:'+2 max energy',    base:160, flat:2},
    {key:'spd',    name:'Thrusters',     desc:'+10% ship speed',  base:110, per:0.10},
    {key:'armor',  name:'Armor',         desc:'-8% incoming dmg', base:140, per:0.08},
    {key:'ram',    name:'Ramming Plate', desc:'+25% collision dmg',base:130, per:0.25},
    {key:'projspd',name:'Projectile Spd',desc:'+15% projectile speed',base:120, per:0.15},
    {key:'range',  name:'Targeting Suite',desc:'+10% weapon range',base:120, per:0.10},
    {key:'squad',  name:'Squad Size',    desc:'+1 concurrent unit',base:200, flat:1},
    {key:'droneR', name:'Drone Optics',  desc:'+15% heal range',  base:110, per:0.15},
    {key:'droneT', name:'Med Throughput',desc:'+20% heal/sec',    base:130, per:0.20},
    {key:'pd',     name:'Point-Defense', desc:'Flagship auto-turret',base:220, flat:1},
    {key:'aura',   name:'Captain‚Äôs Tactics',desc:'+5% global aura',base:180, per:0.05},
    {key:'bossB',  name:'Boss Buster',   desc:'+20% vs bosses',   base:180, per:0.20},
    {key:'salvage',name:'Salvage Bonus', desc:'+4c on kill',      base:140, flat:1},
  ];
  function upgCost(key){ const base = UPG.find(u=>u.key===key).base; const lvl=Player.upgrades[key]||0; return Math.floor(base*Math.pow(1.25,lvl)); }

  function applyStats(){
    Player.energyMax = 10 + (Player.upgrades.cap||0)*2;
    Player.energyRegen = 2.0*(1+(Player.upgrades.erg||0)*0.15); // faster base (2.0)
    Player.hpMax = Math.floor(1100*(1+(Player.upgrades.hp||0)*0.12));
    Player.hp = clamp(Player.hp,0,Player.hpMax);
  }

  // ---------- Spawning ----------
  const Selected={type:'Fighter'};
  const typeCooldown = {Fighter:0, Interceptor:0, Bomber:0, Drone:0, Frigate:0};
  const typeCDLen = {Fighter:0.2, Interceptor:0.5, Bomber:1.0, Drone:1.0, Frigate:1.2};
  let concurrentLimit=1;
  function canAfford(type){ return Player.energy >= BASE[type].cost; }

  // Max deploy mode
  const Modes = { maxDeploy:false };

  function tryDeploy(type, team=TEAM.ALLY){
    if(!playing || paused) return false;

    // cooldown gate for single spawn; allow batch to bypass initial gate
    if(team===TEAM.ALLY && typeCooldown[type]>0 && !Modes.maxDeploy) return false;

    const cost=BASE[type].cost;
    const capBase = 10; // base field cap
    concurrentLimit = 1 + (Player.upgrades.squad||0);
    const cap = capBase + concurrentLimit*4;

    const countAllies = () => ships.filter(s=>s.team===TEAM.ALLY).length;

    if(team===TEAM.ALLY && !canAfford(type)) return false;
    if(team===TEAM.ALLY && countAllies()>=cap) return false;

    // Batch deploy in max mode
    if(team===TEAM.ALLY && Modes.maxDeploy){
      let spawned=0;
      while(Player.energy>=cost && countAllies()<cap){
        Player.energy-=cost;
        spawnShip(type,team);
        spawned++;
        if(spawned>50) break; // safety
      }
      setEnergyHUD();
      typeCooldown[type]=typeCDLen[type]; // standard cooldown after burst
      return spawned>0;
    }

    // Single spawn
    if(team===TEAM.ALLY){
      Player.energy-=cost; setEnergyHUD(); typeCooldown[type]=typeCDLen[type];
    }
    spawnShip(type,team);
    return true;
  }

  // ---------- Ship factory ----------
  function spawnShip(type,team){
    const b=BASE[type], aura=1+(Player.upgrades.aura||0)*0.05;
    const s={
      id:Math.random().toString(36).slice(2),
      type, team,
      x: team===TEAM.ALLY ? Flag.ally.x+50 : Flag.enemy.x-50,
      y: team===TEAM.ALLY ? Flag.ally.y+rand(-120,120) : Flag.enemy.y+rand(-120,120),
      vx:0, vy:0, ang:0,
      hp:Math.floor(b.hp * (1+(Player.upgrades.hp||0)*0.12) * aura),
      hpMax:0, r:b.r, mass:b.mass,
      target:null, cd:0, ranged:b.range>0,
      maxSpd:b.spd*(1+(Player.upgrades.spd||0)*0.10)*aura,
      turn:b.turn, range:b.range*(1+(Player.upgrades.range||0)*0.10),
      dmg:Math.floor(b.dmg * (1+(Player.upgrades.dmg||0)*0.10) * aura),
      healPS: b.heal ? b.heal*(1+(Player.upgrades.droneT||0)*0.20) : 0,
      boom: b.boom||0, boomD:b.boomD||0, proj:b.proj||0,

      // NEW
      meleeCD: 0,
    };

    s.hpMax=s.hp;
    ships.push(s);
    spark(s.x,s.y,TEAM_COLOR(team),10,1.2);
    beep(team===TEAM.ALLY?540:500,.05,.05,'sawtooth');
    return s;
  }

  // ---------- Shooting ----------
  function fire(from, tx, ty, speed=5){
    const a=Math.atan2(ty-from.y, tx-from.x);
    const v=speed*(1+(Player.upgrades.projspd||0)*0.15);
    const spd = from.team===TEAM.ALLY? v : v*1.0;
    shots.push({x:from.x,y:from.y,vx:Math.cos(a)*spd,vy:Math.sin(a)*spd,team:from.team,dmg:from.dmg,life:2.5, r:3});
    spark(from.x,from.y,TEAM_COLOR(from.team),4,.6);
    beep(from.team===TEAM.ALLY?780:700,.04,.04,'square');
  }

  // ---------- Collision Helpers ----------
  function rectCircle(rx,ry,rw,rh,cx,cy,cr){
    const tx=clamp(cx,rx,rx+rw), ty=clamp(cy,ry,ry+rh), dx=cx-tx, dy=cy-ty; return dx*dx+dy*dy<=cr*cr;
  }

  // ---------- Steering ----------
  function steer(s, dt){
    let tgt=null, best=Infinity;
    for(const o of ships){
      if(o.team!==s.team){
        const d = Math.hypot(o.x-s.x,o.y-s.y);
        const ttk = (o.hp / Math.max(1,s.dmg)) + d/100;
        if(ttk<best){ best=ttk; tgt=o; }
      }
    }
    const foeF = (s.team===TEAM.ALLY? Flag.enemy : Flag.ally);
    const dxF = foeF.x - s.x, dyF = foeF.y - s.y, dF = Math.hypot(dxF,dyF);
    if(!tgt || dF<best*0.9) tgt = foeF;

    let desireX=0, desireY=0;

    // SEEK / ARRIVE
    if(tgt){
      const tx = ('w' in tgt) ? tgt.x : tgt.x, ty = ('w' in tgt) ? tgt.y : tgt.y;
      let dx = tx - s.x, dy = ty - s.y, d = Math.hypot(dx,dy)||1;
      const arrive = (s.type === 'Fighter' ? 24 : 80);
      const m = (d<arrive)? lerp(0, s.maxSpd, d/arrive) : s.maxSpd;
      desireX += (dx/d) * m; desireY += (dy/d) * m;
    }

    // KITE for frigates
    if(s.type==='Frigate' && tgt && !('w' in tgt)){
      const dx = tgt.x - s.x, dy = tgt.y - s.y, d=Math.hypot(dx,dy)||1;
      if(d < s.range*0.75){ desireX -= (dx/d)*s.maxSpd*.8; desireY -= (dy/d)*s.maxSpd*.8; }
    }

    // SEPARATION
    // SEPARATION (only from allies so we can stick to enemies)
    let sepX=0, sepY=0, count=0;
    for(const o of ships){
      if(o===s || o.team!==s.team) continue; // <‚Äî only allies
      const dx=o.x-s.x, dy=o.y-s.y, d=Math.hypot(dx,dy)||1;
      if(d<26){ sepX -= dx/d; sepY -= dy/d; count++; } // a bit tighter than 28
    }
    if(count>0){ const k=1.2*s.maxSpd; desireX += (sepX/count)*k; desireY += (sepY/count)*k; }


    // AVOID FLAGSHIPS (unless ramming)
    const foe = (s.team===TEAM.ALLY? Flag.enemy : Flag.ally);
    if(!('w' in tgt)){
      const rx=foe.x-foe.w/2, ry=foe.y-foe.h/2;
      if(rectCircle(rx,ry,foe.w,foe.h,s.x,s.y, s.r+8)){
        const dx = (s.x-foe.x)||1, dy=(s.y-foe.y)||0, d=Math.hypot(dx,dy)||1;
        desireX += (dx/d)*s.maxSpd*1.2; desireY += (dy/d)*s.maxSpd*1.2;
      }
    }

    // UPDATE velocity
    const accX = desireX - s.vx, accY = desireY - s.vy;
    const accMax = 0.15 * 60;
    const aLen = Math.hypot(accX,accY)||1;
    const ax = accX/aLen * Math.min(accMax, aLen);
    const ay = accY/aLen * Math.min(accMax, aLen);
    s.vx += ax*dt*60; s.vy += ay*dt*60;

    const sp = Math.hypot(s.vx,s.vy);
    const max = s.maxSpd*60;
    if(sp>max){ s.vx = s.vx/sp*max; s.vy=s.vy/sp*max; }

    s.vx += rand(-.02,.02)*60*dt; s.vy += rand(-.02,.02)*60*dt;

    s.x += s.vx*dt; s.y += s.vy*dt;
    s.y = clamp(s.y, 40, cv.height-40);
  }

  // ---------- Damage ----------
  function applyDamage(target, amount, sourceTeam){
    if(amount<=0) return;

    const armor= (target.team===TEAM.ALLY? Player.upgrades.armor||0 : 0);
    const scale = target.team===TEAM.ALLY ? (1-armor*0.08) : 1;
    let amt = Math.max(1, Math.floor(amount*scale));

    if(boss && target===boss && (sourceTeam===TEAM.ALLY)){
      amt = Math.floor(amt*(1+(Player.upgrades.bossB||0)*0.20));
    }

    // Redirect flagship damage to pools (prevents mirror from overwriting)
    if(target === Flag.enemy){ Enemy.hp = Math.max(0, Enemy.hp - amt); return; }
    if(target === Flag.ally){ Player.hp = Math.max(0, Player.hp - amt); return; }

    target.hp -= amt;
  }

  // ---------- Updates ----------
  function updateShips(dt){
    for(const k in typeCooldown){ typeCooldown[k]=Math.max(0, typeCooldown[k]-dt); updateDeployCD(k); }
    heals.length=0;

    for(let i=ships.length-1;i>=0;i--){
      const s=ships[i];
        // Safe: works even if s.meleeCD was never defined
        
        
      steer(s,dt);
      
        // --- RELIABLE FIGHTER MELEE DPS ON CONTACT ---
      if (s.type === 'Fighter') {
        // Find any *one* enemy touching us (closest first)
        let victim = null, best = Infinity;
        for (const o of ships) {
          if (o.team === s.team) continue;
          const d = Math.hypot(o.x - s.x, o.y - s.y);
          const FIGHTER_MELEE_RANGE = 26; // damage when within ~26px, not just overlap
          if (d < Math.max(FIGHTER_MELEE_RANGE, s.r + o.r + FIGHTER_MELEE_PAD) && d < best) {
            best = d; victim = o;
          }
        }
        if (victim) {
          // Apply continuous DPS so sliding/side-jitter still deals damage
          const dps = s.dmg * FIGHTER_MELEE_DPS_MULT; // scales with upgrades (uses s.dmg)
          applyDamage(victim, dps * dt, s.team);
          // (optional) tiny spark for feedback
          if (Math.random() < 0.12) spark((s.x+victim.x)/2, (s.y+victim.y)/2, '#fff', 4, 0.8);
        }
      }


      s.meleeCD = Math.max(0, (s.meleeCD || 0) - dt);

      // firing / melee
      s.cd -= dt;
      if(s.type==='Fighter'){ /* melee via collisions */ }
      else if(s.ranged){
        let tgt=null, best=Infinity;
        for(const o of ships){ if(o.team!==s.team){
          const d = Math.hypot(o.x-s.x,o.y-s.y); if(d<best){best=d; tgt=o;}
        }}
        const foeF = (s.team===TEAM.ALLY? Flag.enemy:Flag.ally);
        const dF = Math.abs(foeF.x - s.x);
        if(!tgt || dF<best) tgt=foeF;

        const dx = (('w' in tgt)? tgt.x - s.x : tgt.x - s.x);
        const dy = (('w' in tgt)? tgt.y - s.y : tgt.y - s.y);
        const dist = Math.hypot(dx,dy);
        if(dist < s.range && s.cd<=0){
          s.cd = (s.type==='Frigate'? .75 : (s.type==='Interceptor'? .5 : 1.0));
          fire(s, s.x+dx, s.y+dy, s.type==='Frigate'? 6.2 : 5.0);
        }
      } else if(s.type==='Drone'){
        let best=null, br=Infinity;
        const r = (BASE.Drone.range*(1+(Player.upgrades.droneR||0)*0.15));
        for(const o of ships){ if(o.team===s.team && o!==s && o.hp<o.hpMax){
          const d=Math.hypot(o.x-s.x,o.y-s.y); if(d<r && o.hp/o.hpMax < br){ br=o.hp/o.hpMax; best=o; }
        }}
        if(best){
          heals.push({x1:s.x,y1:s.y,x2:best.x,y2:best.y,t:0});
          best.hp = Math.min(best.hpMax, best.hp + s.healPS*dt);
          if(Math.random()<.2) spark(best.x,best.y,'#aef',2,.3);
        }
      }

      if(s.hp<=0){
        if(s.boom){
          ringBlast(s.x,s.y,TEAM_COLOR(s.team), 10);
          for(const o of ships){ if(o.team!==s.team && Math.hypot(o.x-s.x,o.y-s.y) < s.boom){ applyDamage(o, s.boomD, s.team); } }
          addShake(8);
        }
        if(s.team===TEAM.ENEMY && (Player.upgrades.salvage||0)>0){
          Player.credits += 4*(Player.upgrades.salvage||0); setMoneyHUD();
        }
        spark(s.x,s.y,TEAM_COLOR(s.team),14,1.6); beep(160,.06,.06,'triangle');
        ships.splice(i,1);
      }
    }
  }

  function collisions(dt){
    // ship<->ship circles
    for(let i=0;i<ships.length;i++){
      const a=ships[i];
      for(let j=i+1;j<ships.length;j++){
        const b=ships[j];
        const dx=b.x-a.x, dy=b.y-a.y; 
        const dist=Math.hypot(dx,dy);
        const min = a.r + b.r;

        if(dist<min){
          const nx = dx/(dist||1), ny = dy/(dist||1);
          const overlap = (min - dist);

          // separate
          a.x -= nx*overlap*.5; a.y -= ny*overlap*.5;
          b.x += nx*overlap*.5; b.y += ny*overlap*.5;

          // physics impact calc
          const rel = Math.abs((b.vx-a.vx)*nx + (b.vy-a.vy)*ny);
          const base = 0.05 * (a.mass + b.mass) * rel * (Player.upgrades.ram ? 1 + Player.upgrades.ram*0.25 : 1);

          if (a.team !== b.team) {
  // -------- MASS-WEIGHTED PUSH + LOW CHIP DAMAGE --------
  // rel = relative speed along the collision normal (already computed above)

  // Tuning knobs (all local; tweak here if needed)
  const RESTITUTION    = 0.20;   // 0 = sticky, 1 = super bouncy
  const PUSH_GAIN      = 20.0;   // overall push strength
  const PUSH_CAP       = 60.0;   // cap the push so it doesn't explode apart
  const DMG_PER_IMPULSE= 0.08;   // convert push impulse to damage (low = chip)
  const DMG_CAP        = 10.0;   // max damage per collision tick

  // Effective mass for a 1D collision impulse (heavier ships impart/absorb more)
  const mA = Math.max(0.1, a.mass), mB = Math.max(0.1, b.mass);
  const mEff = (mA * mB) / (mA + mB);

  // Base impulse along the normal (mass-weighted), includes a touch of restitution
  let J = (rel * (1 + RESTITUTION)) * mEff * PUSH_GAIN * (Player.upgrades.ram ? (1 + Player.upgrades.ram*0.25) : 1);
  J = Math.min(J, PUSH_CAP);

  // Apply equal & opposite impulses; heavy ships move less for the same impulse
  a.vx -= nx * (J / mA); a.vy -= ny * (J / mA);
  b.vx += nx * (J / mB); b.vy += ny * (J / mB);

  // Low chip damage based on impulse; scale by *opponent* mass so heavier hitters hurt more
  const dmgToB = Math.min(DMG_CAP, J * DMG_PER_IMPULSE * (mA / 1.5));
  const dmgToA = Math.min(DMG_CAP, J * DMG_PER_IMPULSE * (mB / 1.5));

  if (dmgToB > 0.25) applyDamage(b, dmgToB, a.team);
  if (dmgToA > 0.25) applyDamage(a, dmgToA, b.team);

  // (Keep your Fighter melee/DPS-on-contact code right after this if you have it)
}


        }
      }

      // ship with enemy flagship
      const foeF = (a.team===TEAM.ALLY? Flag.enemy : Flag.ally);
      const rx=foeF.x-foeF.w/2, ry=foeF.y-foeF.h/2;
      if(rectCircle(rx,ry,foeF.w,foeF.h,a.x,a.y,a.r)){
        const dir = Math.sign(a.x-foeF.x)||1;
        a.vx += dir*60*dt; a.x += dir*14;

        // toned-down flagship collision so Fighters don't evaporate on graze
        const vsFlagScale = (a.type==='Fighter' ? 0.35 : 0.8);
        applyDamage(foeF, a.mass*8 * vsFlagScale, a.team);
        applyDamage(a,    a.mass*9 * vsFlagScale, foeF.team);

        spark(a.x,a.y,TEAM_COLOR(a.team),8,1.2); addShake(4);
      }
    }

    // shots
    for(let i=shots.length-1;i>=0;i--){
      const b=shots[i]; b.x+=b.vx*dt*60; b.y+=b.vy*dt*60; b.life-=dt;
      if(b.life<=0){ shots.splice(i,1); continue; }

      // ship hit
      let hit=false;
      for(const s of ships){ if(s.team!==b.team){
        if(Math.hypot(s.x-b.x,s.y-b.y) < s.r + b.r){
          applyDamage(s, b.dmg, b.team); hit=true; spark(b.x,b.y,TEAM_COLOR(b.team),6,1.0); break;
        }
      }}

      // flagship hit
      if(!hit){
        const foeF = (b.team===TEAM.ALLY? Flag.enemy : Flag.ally);
        const rx=foeF.x-foeF.w/2, ry=foeF.y-foeF.h/2;
        if(rectCircle(rx,ry,foeF.w,foeF.h,b.x,b.y,6)){ hit=true; applyDamage(foeF, Math.floor(b.dmg*1.2), b.team); addShake(4); }
      }

      if(hit){ shots.splice(i,1); }
      else if(b.x<-40||b.x>cv.width+40||b.y<-40||b.y>cv.height+40){ shots.splice(i,1); }
    }
  }

  // ---------- Boss ----------
  function spawnBoss(){
    bossActive=true; Enemy.specialUsed=false;
    boss={ x:cv.width-200, y:cv.height*0.5, vx:-30, vy:0, w:36, h:220, hp:1400*(1+Round*0.15), hpMax:0, shield:0, cd:3, team:TEAM.ENEMY };
    boss.hpMax=boss.hp;
    toast('‚ö† Boss incoming!');
  }
  function updateBoss(dt){
    if(!boss) return;
    boss.x += boss.vx*dt;
    boss.cd -= dt;
    if(boss.cd<=0){
      boss.cd = 6;
      for(const s of ships){ if(s.team===TEAM.ALLY && Math.abs(s.x-boss.x)<280){ applyDamage(s,18, TEAM.ENEMY); s.vx -= 50; } }
      addShake(6); ringBlast(boss.x,boss.y,'#ff9ab3',12);
      for(let i=0;i<2;i++) spawnShip(Math.random()<.5?'Interceptor':'Frigate', TEAM.ENEMY);
    }
    if(boss.x - boss.w/2 < Flag.ally.x + Flag.ally.w/2){ Player.hp=0; }
  }
  function drawBoss(){
    if(!boss) return;
    const rx=boss.x-boss.w/2, ry=boss.y-boss.h/2;
    if(Settings.bloom){ ctx.globalAlpha=.25; ctx.fillStyle='rgba(255,77,122,.25)'; ctx.fillRect(rx-8,ry-8,boss.w+16,boss.h+16); ctx.globalAlpha=1; }
    ctx.strokeStyle='#ff4d7a'; ctx.lineWidth=3*DPR;
    ctx.strokeRect(rx,ry,boss.w,boss.h);
    ctx.fillStyle='rgba(255,255,255,.06)'; ctx.fillRect(rx-10,ry-10,boss.w+20,6);
    ctx.fillStyle='#ff4d7a'; ctx.fillRect(rx-10,ry-10,(boss.w+20)*(boss.hp/boss.hpMax),6);
  }

  // ---------- Flagships ----------
  function drawFlag(fs, color){
    const rx=fs.x-fs.w/2, ry=fs.y-fs.h/2;
    if(Settings.bloom){ ctx.globalAlpha=.25; ctx.fillStyle=color; ctx.fillRect(rx-10,ry-10,fs.w+20,fs.h+20); ctx.globalAlpha=1; }
    ctx.strokeStyle=color; ctx.lineWidth=3*DPR;
    ctx.beginPath();
    if(fs===Flag.ally){
      ctx.moveTo(rx,ry); ctx.lineTo(rx+fs.w,ry+fs.h*.18); ctx.lineTo(rx+fs.w,ry+fs.h*.82); ctx.lineTo(rx,ry+fs.h); ctx.closePath();
    }else{
      ctx.moveTo(rx+fs.w,ry); ctx.lineTo(rx,ry+fs.h*.18); ctx.lineTo(rx,ry+fs.h*.82); ctx.lineTo(rx+fs.w,ry+fs.h); ctx.closePath();
    }
    ctx.stroke();
    const r = (fs.hp/fs.hpMax);
    ctx.fillStyle='rgba(255,255,255,.06)';
    const bx = fs===Flag.ally ? rx-8 : rx+fs.w+2;
    ctx.fillRect(bx,ry,6,fs.h);
    ctx.fillStyle=color; ctx.fillRect(bx,ry+(1-r)*fs.h,6,fs.h*r);
  }

  // ---------- AI ----------
  const AI={ timer:1.0 };
  function pickPersonality(){
    Enemy.personality = ['rusher','balanced','harasser'][ (Round%3) ];
  }
  function estimatePlayerComp(){
    const counts={Fighter:0,Interceptor:0,Bomber:0,Drone:0,Frigate:0};
    for(const s of ships){ if(s.team===TEAM.ALLY) counts[s.type]++; }
    return counts;
  }
  function aiTick(dt){
    Enemy.energy = Math.min(Enemy.energyMax, Enemy.energy + Enemy.energyRegen*dt);
    AI.timer -= dt;
    if(AI.timer<=0){
      AI.timer = rand(.7,1.1) * (Settings.difficulty===2?0.85:1);
      const comp = estimatePlayerComp();
      const opts = [];
      if(comp.Bomber+comp.Frigate>2) opts.push('Interceptor','Interceptor');
      if(comp.Drone>0) opts.push('Fighter');
      if(Enemy.personality==='rusher') opts.push('Fighter','Fighter','Bomber');
      if(Enemy.personality==='harasser') opts.push('Frigate','Interceptor');
      opts.push('Drone');
      opts.push('Frigate','Interceptor','Fighter','Bomber');

      let choice=null;
      for(let tries=0;tries<6;tries++){
        const t = opts[randi(0,opts.length)];
        const need = BASE[t].cost*Enemy.difficultyBias;
        if(Enemy.energy >= need){ choice=t; break; }
      }
      if(!choice && Enemy.energy>=BASE.Bomber.cost*1.0) choice='Bomber';

      if(choice){
        Enemy.energy -= BASE[choice].cost*Enemy.difficultyBias;
        spawnShip(choice, TEAM.ENEMY);
      }

      if(!Enemy.specialUsed && Round>=2 && Math.random()<0.2){
        Enemy.specialUsed=true;
        for(const s of ships){ if(s.team===TEAM.ENEMY) s.cd = Math.max(0,s.cd-0.4); }
        toast('Enemy tactics spike!');
      }
    }
  }

  // ---------- UI: deploy bar ----------
  const deployBar = $('deployBar');
  function makeDeployBar(){
    deployBar.innerHTML = '';
    ORDER.forEach((t,i)=>{
      const c = document.createElement('div'); c.className='card';
      c.innerHTML = `<button class="btn" data-type="${t}">${i+1}. ${t}</button>
        <span class="badge">Cost ${BASE[t].cost}</span>
        <div class="grow"></div>
        <div class="cooldown" style="width:80px"><i id="cd_${t}"></i></div>`;
      deployBar.appendChild(c);
    });
    deployBar.addEventListener('click', e=>{
      const b = e.target.closest('button[data-type]'); if(!b) return;
      Selected.type = b.dataset.type; tryDeploy(Selected.type, TEAM.ALLY) || beep(220,.05,.05,'triangle');
    });
  }
  function updateDeployCD(t){
    const el = $('cd_'+t); if(!el) return;
    const len = typeCDLen[t], left = clamp(typeCooldown[t]/len,0,1);
    el.style.width = ((1-left)*100)+'%';
  }

  // ---------- Menus ----------
  function show(id, on=true){ $(id).classList.toggle('show', on); }
  function start(){
    show('title',false); playing=true; paused=false; gameOver=false;
    Round=1; roundTime=0; nextBossIn= (Round%5===0? 2 : 0); bossActive=false; boss=null;
    resetBattle();
  }
  function resetBattle(){
    ships.length=0; shots.length=0; parts.length=0; heals.length=0; boss=null; bossActive=false;
    Player.hpMax = Math.floor(1100*(1+(Player.upgrades.hp||0)*0.12)); Player.hp = Player.hpMax;
    Enemy.hpMax  = Player.hpMax; Enemy.hp = Enemy.hpMax;
    Flag.ally.hpMax=Player.hpMax; Flag.ally.hp=Player.hp;
    Flag.enemy.hpMax=Enemy.hpMax; Flag.enemy.hp=Enemy.hp;
    Player.energy=0; Enemy.energy=0;
    AI.timer=1.0; Enemy.specialUsed=false; pickPersonality();
    setHPHUD(); setEnergyHUD(); setRoundHUD(); setMoneyHUD(); setBossHUD();
  }

  // ---------- Buttons & Keys ----------
  $('startBtn').addEventListener('click', ()=>{ initAudio(); start(); });
  $('openShopFromTitle').addEventListener('click', ()=>{ buildShop(); show('shop',true); });
  $('toMenuFromShop').addEventListener('click', ()=>{
    // leave shop and go to title safely
    show('shop', false);
    show('title', true);
    // ensure we‚Äôre not in an in-between state
    playing = false;
    paused = false;
    gameOver = false;
    // (optional) reset the battle state so starting again is clean
    resetBattle();
  });

  $('resumeBtn').addEventListener('click', ()=> show('pause',false));
  $('restartBtn').addEventListener('click', ()=>{ show('pause',false); resetBattle(); playing=true; });
  $('toTitleBtn').addEventListener('click', ()=>{ show('pause',false); show('title',true); playing=false; });
  $('spendBtn').addEventListener('click', ()=>{ show('gameover',false); buildShop(); show('shop',true); });
  $('nextBtn').addEventListener('click', ()=>{
    show('gameover',false);
    const mode = $('nextBtn').dataset.mode || 'next';
    if(mode==='retry'){
      roundTime=0; nextBossIn = (Round%5===0? 3 : 0);
      resetBattle(); playing=true;
    }else{
      Round++; roundTime=0; nextBossIn = (Round%5===0? 3 : 0);
      resetBattle(); playing=true;
    }
  });
  $('quitBtn').addEventListener('click', ()=>{ show('gameover',false); show('title',true); playing=false; });

  $('speedBtn').addEventListener('click', ()=>{
    const idx = Speed.steps.indexOf(Speed.mult);
    Speed.mult = Speed.steps[(idx+1)%Speed.steps.length];
    setSpeedHUD(); toast(`Speed ${Speed.mult}√ó`);
  });
  $('helpBtn').addEventListener('click', ()=> toast('1‚Äì5 pick ship, Space deploy, P pause. Spend credits in Shop. Use ‚ÄúMax Deploy‚Äù to burst.'));
  $('shotBtn').addEventListener('click', ()=>{
    try{ const a=document.createElement('a'); a.download=`void-wars-${Date.now()}.png`; a.href=cv.toDataURL('image/png'); a.click(); }catch{}
  });
  $('maxBtn').addEventListener('click', (e)=>{
    Modes.maxDeploy = !Modes.maxDeploy;
    e.currentTarget.textContent = `‚®â Max Deploy: ${Modes.maxDeploy ? 'On' : 'Off'}`;
    toast(Modes.maxDeploy ? 'Max deploy enabled' : 'Max deploy disabled');
  });

  addEventListener('keydown', e=>{
    if(e.code==='KeyP'){ show('pause', !$('pause').classList.contains('show')); }
    if(e.code==='Space'){ tryDeploy(Selected.type, TEAM.ALLY); }
    if(e.code==='Digit1') Selected.type='Fighter';
    if(e.code==='Digit2') Selected.type='Interceptor';
    if(e.code==='Digit3') Selected.type='Bomber';
    if(e.code==='Digit4') Selected.type='Drone';
    if(e.code==='Digit5') Selected.type='Frigate';
  });

  // Options
  document.querySelectorAll('[data-diff]').forEach(b=> b.addEventListener('click', ()=>{
    document.querySelectorAll('[data-diff]').forEach(x=>x.classList.remove('primary','danger'));
    const v=Number(b.dataset.diff); Settings.difficulty=v; b.classList.add(v===2?'danger':'primary');
    Enemy.energyRegen = v===2?1.3:(v===1?1.15:1.0);
    Enemy.difficultyBias = v===2?1.15:(v===0?0.9:1.0);
    Player.hpMax = v===0?1200:(v===2?1050:1100); Player.hp=Player.hpMax;
    setHPHUD(); toast(`Difficulty: ${['Easy','Normal','Hard'][v]}`);
  }));
  $('optParticles').addEventListener('change', e=>Settings.particles=e.target.checked);
  $('optBloom').addEventListener('change', e=>Settings.bloom=e.target.checked);
  $('optShake').addEventListener('change', e=>Settings.shake=e.target.checked);
  $('optSfx').addEventListener('change', e=>Settings.sfx=e.target.checked);
  $('optVol').addEventListener('input', e=> masterVol=Number(e.target.value));

  // ---------- Shop UI ----------
  function buildShop(){
    const list=$('shopList'); list.innerHTML='';
    UPG.forEach(u=>{
      const lvl = Player.upgrades[u.key]||0;
      const cost = upgCost(u.key);
      const item = document.createElement('div');
      item.className='shop-item';
      item.innerHTML = `<strong>${u.name}</strong><span class="badge">Lv ${lvl}</span><span class="badge">${u.desc}</span>
        <span class="price badge">Cost ${cost}</span>
        <button class="btn small" data-upg="${u.key}">Buy</button>`;
      list.appendChild(item);
    });
    list.addEventListener('click', onBuyOnce, {once:true});
    setMoneyHUD();
  }
  function onBuyOnce(e){
    const btn = e.target.closest('button[data-upg]'); if(!btn) {
      $('shopList').addEventListener('click', onBuyOnce, {once:true}); return;
    }
    const key = btn.dataset.upg;
    const cost = upgCost(key);
    if(Player.credits>=cost){
      Player.credits -= cost; Player.upgrades[key]=(Player.upgrades[key]||0)+1;
      applyStats(); setMoneyHUD(); toast(`Upgraded ${key} ‚Äî next ${upgCost(key)}c`);
      buildShop();
    }else toast('Not enough credits');
    $('shopList').addEventListener('click', onBuyOnce, {once:true});
  }

  // ---------- Drawing ----------
  function drawShip(s){
    const stroke=TEAM_COLOR(s.team), accent=TYPE_ACCENT[s.type]||stroke;
    if(Settings.bloom){ ctx.globalAlpha=.22; ctx.fillStyle=(s.team===TEAM.ALLY?'rgba(0,245,255,.25)':'rgba(255,77,122,.25)'); ctx.beginPath(); ctx.arc(s.x,s.y,16,0,TAU); ctx.fill(); ctx.globalAlpha=1; }
    ctx.strokeStyle=stroke; ctx.lineWidth=2*DPR;

    const ang = Math.atan2(s.vy,s.vx)||0;
    ctx.save(); ctx.translate(s.x,s.y); ctx.rotate(ang);

    ctx.beginPath();
    if(s.type==='Fighter'){
      ctx.moveTo(12,0); ctx.lineTo(-10,-8); ctx.lineTo(-10,8); ctx.closePath();
    }else if(s.type==='Interceptor'){
      ctx.moveTo(13,0); ctx.lineTo(0,-10); ctx.lineTo(-13,0); ctx.lineTo(0,10); ctx.closePath();
    }else if(s.type==='Bomber'){
      ctx.moveTo(14,0); ctx.lineTo(-12,-9); ctx.lineTo(-12,9); ctx.closePath();
    }else if(s.type==='Drone'){
      ctx.arc(0,0,9,0,TAU);
    }else if(s.type==='Frigate'){
      for(let i=0;i<6;i++){ const a=Math.PI/6 + i*TAU/6; const px=Math.cos(a)*12, py=Math.sin(a)*12; if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py); }
      ctx.closePath();
    }
    ctx.stroke();
    ctx.strokeStyle=accent; ctx.lineWidth=1.5*DPR;
    if(s.type==='Interceptor'){ ctx.beginPath(); ctx.moveTo(-12,-6); ctx.lineTo(-18,-2); ctx.moveTo(-12,6); ctx.lineTo(-18,2); ctx.stroke(); }
    if(s.type==='Bomber'){ ctx.beginPath(); ctx.moveTo(-8,-6); ctx.lineTo(-8,6); ctx.stroke(); }
    if(s.type==='Frigate'){ ctx.beginPath(); ctx.moveTo(8,-6); ctx.lineTo(16,-10); ctx.moveTo(8,6); ctx.lineTo(16,10); ctx.stroke(); }
    ctx.restore();

    const w=24,h=4;
    ctx.fillStyle='rgba(255,255,255,.08)'; ctx.fillRect(s.x-w/2, s.y-18, w, h);
    ctx.fillStyle=stroke; ctx.fillRect(s.x-w/2, s.y-18, (s.hp/s.hpMax)*w, h);
  }

  function drawHeals(){
    for(const h of heals){
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle='#aef'; ctx.lineWidth=2*DPR;
      ctx.beginPath(); ctx.moveTo(h.x1,h.y1); ctx.lineTo(h.x2,h.y2); ctx.stroke();
      ctx.globalCompositeOperation='source-over';
    }
  }

  function drawShots(){
    ctx.globalCompositeOperation='lighter';
    for(const b of shots){
      ctx.strokeStyle=TEAM_COLOR(b.team); ctx.lineWidth=2.4*DPR;
      ctx.beginPath(); ctx.moveTo(b.x-b.vx*.8, b.y-b.vy*.8); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
    ctx.globalCompositeOperation='source-over';
  }

  // ---------- Round flow ----------
  function victory(v){
    playing=false; gameOver=true;
    const dealt = Math.max(0, Enemy.hpMax-Enemy.hp);
    const taken = Math.max(0, Player.hpMax-Player.hp);
    const reward = (v? (200+Round*35) : (70+Round*16)) + (bossActive? 120:0);
    Player.credits += reward; setMoneyHUD();
    $('resultTitle').textContent = v? 'Victory' : 'Defeat';
    $('statsText').textContent = `Round ${Round} ‚Äî Damage Dealt: ${dealt} ¬∑ Taken: ${taken} ¬∑ Reward: +${reward}c`;

    const nextBtn = $('nextBtn');
    if(v){
      nextBtn.textContent = '‚ñ∂ Next Round';
      nextBtn.dataset.mode = 'next';
    }else{
      nextBtn.textContent = '‚Ü∫ Retry';
      nextBtn.dataset.mode = 'retry';
    }
    show('gameover',true);
  }

  // ---------- Main loop ----------
  let last=performance.now(), acc=0, dt=1/60;
  makeDeployBar(); setSpeedHUD();

  function frame(){
    const now=performance.now(), raw=(now-last)/1000; last=now;
    acc += raw * Speed.mult;

    if(audioCtx) audioCtx.suspend && (Speed.mult<1.01 && !paused ? audioCtx.suspend() : audioCtx.resume());

    while(acc>=dt){
      acc-=dt;
      if(playing && !paused){
        roundTime += dt; setTimeHUD();
        Player.energy = Math.min(Player.energyMax, Player.energy + Player.energyRegen*dt); setEnergyHUD();
        Enemy.energy = Math.min(Enemy.energyMax, Enemy.energy + Enemy.energyRegen*dt);
        if(Round%5===0 && !bossActive){
          nextBossIn = Math.max(0, nextBossIn - dt); setBossHUD();
          if(nextBossIn<=0) spawnBoss();
        }
        updateShips(dt);
        collisions(dt);
        aiTick(dt);
        if(bossActive){ updateBoss(dt); if(boss && boss.hp<=0){ boss=null; bossActive=false; toast('Boss defeated!'); } }
        // Mirror pools to flags (no overwrite of damage thanks to applyDamage redirect)
        Flag.ally.hp = Player.hp; Flag.ally.hpMax=Player.hpMax;
        Flag.enemy.hp = Enemy.hp; Flag.enemy.hpMax=Enemy.hpMax;

        if(Enemy.hp<=0 && (!boss || boss.hp<=0)) victory(true);
        if(Player.hp<=0) victory(false);
      }
      partsUpdate(dt);
    }

    ctx.clearRect(0,0,cv.width,cv.height);
    drawBackground(raw);
    applyCamera();

    ctx.strokeStyle='rgba(255,255,255,.06)'; ctx.beginPath(); ctx.moveTo(cv.width/2,0); ctx.lineTo(cv.width/2,cv.height); ctx.stroke();

    drawFlag(Flag.ally, '#00faff');
    drawFlag(Flag.enemy, '#ff4d7a');
    if(bossActive) drawBoss();

    for(const s of ships) drawShip(s);
    drawShots();
    drawHeals();
    partsDraw();

    resetCamera();
    setHPHUD();
    requestAnimationFrame(frame);
  }
  frame();

})();
</script>
</body>
</html>
